---
import BaseLayout from '../layouts/BaseLayout.astro';

export const prerender = false;
---

<BaseLayout
	title="Rehearsal Studio | Mandolin Balaji"
	description="Master your music with synchronized lyrics, notation, and independent pitch/speed control"
>
	<div class="practice-studio">
		<!-- Header Section -->
		<header class="studio-header">
			<div class="header-content">
				<h1 class="studio-title">Rehearsal Studio</h1>
				<p class="studio-subtitle">Master your music with precision timing</p>
				<div id="song-metadata" class="song-info hidden">
					<div class="song-title" id="song-title"></div>
					<div class="song-details">
						<span class="ragam">
							<span class="label">Raagam:</span>
							<span class="value" id="ragam-text"></span>
						</span>
						<span class="talam">
							<span class="label">Taalam:</span>
							<span class="value" id="talam-text"></span>
						</span>
						<span class="shruti">
							<span class="label">Shruti:</span>
							<span class="value" id="shruti-text"></span>
						</span>
					</div>
					<div class="song-scales">
						<span class="arohanam">
							<span class="label">Aroh:</span>
							<span class="value" id="arohanam-text"></span>
						</span>
						<span class="avarohanam">
							<span class="label">Ava:</span>
							<span class="value" id="avarohanam-text"></span>
						</span>
					</div>
				</div>
			</div>
		</header>

		<!-- Main Content Area -->
		<main class="studio-main">
			<!-- Practice Display -->
			<div id="practice-display" class="practice-display hidden">
				<!-- Notation Panel -->
				<div id="notation-panel" class="panel notation-panel hidden">
					<div class="panel-header">
						<h3>Musical Notation</h3>
						<button class="panel-toggle" data-panel="notation">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<polyline points="18,15 12,9 6,15"></polyline>
							</svg>
						</button>
					</div>
					<div class="panel-content">
						<div id="current-notation" class="notation-content">
							Notation will appear here
						</div>
					</div>
				</div>

				<!-- Lyrics Panel -->
				<div id="lyrics-panel" class="panel lyrics-panel">
					<div class="panel-header">
						<h3>Lyrics & Timing</h3>
						<div class="panel-controls">
							<button class="panel-toggle" data-panel="lyrics">
								<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
									<polyline points="6,9 12,15 18,9"></polyline>
								</svg>
							</button>
						</div>
					</div>
					<div class="panel-content">
						<div class="lyrics-content">
							<div id="current-lyric" class="current-lyric-line">
								Select audio file to begin practice
							</div>
							<div id="count-in-countdown" class="count-in-countdown hidden"></div>
							<div id="upcoming-lyrics" class="upcoming-lyrics-preview">
								<!-- Upcoming lyrics will appear here -->
							</div>
						</div>
					</div>
				</div>

				<!-- Loop Area - Above Progress Bar -->
				<div id="loop-section" class="control-section loop-section hidden">
					<div id="loop-controls" class="loop-controls">
						<div class="loop-visualizer">
							<div class="loop-track">
								<div id="loop-area" class="loop-area"></div>
								<div id="loop-markers" class="loop-markers"></div>
								<div id="loop-start-handle" class="loop-handle loop-start">
									<div class="loop-grip">A</div>
								</div>
								<div id="loop-end-handle" class="loop-handle loop-end">
									<div class="loop-grip">B</div>
								</div>
							</div>
						</div>
					</div>
				</div>

				<!-- Progress Bar with Timeline Markers - Below Loop Area -->
				<div id="progress-section" class="control-section progress-section hidden">
					<div class="time-display">
						<span id="current-time">0:00</span>
						<span id="duration">0:00</span>
					</div>
					<div class="progress-container">
						<div class="progress-bar">
							<div id="progress-fill" class="progress-fill"></div>
							<input type="range" id="seek-bar" min="0" max="100" value="0" />
						</div>
						<div id="timeline-markers" class="timeline-markers"></div>
						<div class="playhead-indicator">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M7 10l5 5 5-5z"/>
							</svg>
						</div>
					</div>
				</div>

				<!-- Transport & Loop Controls - Below Loop Area -->
				<div class="control-section playback-controls-section hidden">
					<div class="playback-controls">
						<button id="play-pause" class="transport-button play-button">
							<svg class="play-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
								<path d="M8 5v14l11-7z"/>
							</svg>
							<svg class="pause-icon hidden" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
								<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
							</svg>
						</button>
						<button id="stop" class="transport-button">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
							</svg>
						</button>
						<label class="control-label loop-label">
							<input type="checkbox" id="loop-enable" />
							<span>A-B</span>
						</label>
						<button id="count-in-button" class="transport-button count-in-square" title="Count-in">
								<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2">
									<text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" font-size="12" font-weight="bold">üéµ</text>
									<rect x="2" y="2" width="20" height="20" fill="none" stroke="currentColor"/>
								</svg>
							</button>
					</div>
				</div>
			</div>

			<!-- Control Panel -->
			<div class="control-panel">
                <div class="count-in-controls">
							<label for="count-in-bpm" class="bpm-label">BPM:</label>
							<input type="number" id="count-in-bpm" class="bpm-input" value="120" min="40" max="300" />
							<select id="count-in-beats-dropdown">
								<option value="4" selected>4</option>
                                <option value="3">3</option>
								<option value="5">5</option>
								<option value="6">6</option>
								<option value="7">7</option>
								<option value="8">8</option>
								<option value="9">9</option>
								<option value="10">10</option>
							</select>
							
						</div>
				<!-- File Input Section -->
				<div id="file-inputs-section" class="control-section file-inputs-section">
					<div class="control-group">
						<label class="file-input-label">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M9 18V5l12-2v13"></path>
								<circle cx="6" cy="18" r="3"></circle>
								<circle cx="18" cy="16" r="3"></circle>
							</svg>
							<span>Load Audio File</span>
							<input type="file" id="audio-file" accept="audio/mp3,audio/mpeg" hidden />
						</label>
						<button id="load-button" class="primary-button" disabled>
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M5 12h14M12 5l7 7-7 7"/>
							</svg>
							Start Practice
						</button>
					</div>
				</div>

				<!-- Advanced Controls -->
				<div id="advanced-controls" class="control-section advanced-controls hidden">
					<div class="control-row">
						<div class="control-group">
							<label class="control-label">Speed</label>
							<div class="slider-group">
								<button id="speed-down" class="adjust-button">-</button>
								<span id="speed-display" class="value-display">1.0x</span>
								<button id="speed-up" class="adjust-button">+</button>
								<button id="speed-reset" class="reset-button">‚Ü∫</button>
							</div>
						</div>

						<div class="control-group">
							<label class="control-label">Pitch</label>
							<div class="slider-group">
								<button id="pitch-down" class="adjust-button">-</button>
								<span id="pitch-display" class="value-display">0</span>
								<button id="pitch-up" class="adjust-button">+</button>
								<button id="pitch-reset" class="reset-button">‚Ü∫</button>
							</div>
						</div>
					</div>

					<div class="control-group">
						<label class="control-label">Volume</label>
						<input type="range" id="volume" min="0" max="100" value="80" />
					</div>
				</div>
			</div>
		</main>
	</div>
</BaseLayout>

<style>
	.practice-studio {
		display: flex;
		flex-direction: column;
		min-height: 100vh;
		background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
		color: #ffffff;
	}

	/* Header Styles */
	.studio-header {
		background: rgba(0, 0, 0, 0.8);
		border-bottom: 1px solid rgba(255, 255, 255, 0.1);
		padding: 1.5rem;
		backdrop-filter: blur(10px);
	}

	.header-content {
		max-width: 1200px;
		margin: 0 auto;
		text-align: center;
	}

	.studio-title {
		font-size: clamp(2rem, 5vw, 3rem);
		font-weight: 700;
		margin: 0 0 0.5rem 0;
		background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
		background-clip: text;
	}

	.studio-subtitle {
		font-size: clamp(1rem, 2.5vw, 1.25rem);
		color: rgba(255, 255, 255, 0.7);
		margin: 0 0 1.5rem 0;
		font-weight: 300;
	}

	.song-info {
		background: rgba(255, 255, 255, 0.05);
		border-radius: 12px;
		padding: 1rem;
		margin-top: 1rem;
		border: 1px solid rgba(255, 255, 255, 0.1);
	}

	.song-title {
		font-size: 1.25rem;
		font-weight: 600;
		color: #4ecdc4;
		margin-bottom: 0.5rem;
	}

	.song-details {
		display: flex;
		gap: 2rem;
		justify-content: center;
		flex-wrap: wrap;
	}

	.arohanam, .avarohanam, .ragam, .talam, .sruthi {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.label {
		font-weight: 500;
		color: rgba(255, 255, 255, 0.6);
		min-width: 3rem;
	}

	.value {
		font-family: 'Courier New', monospace;
		font-weight: 600;
		color: #ff6b6b;
	}

	/* Main Content */
	.studio-main {
		flex: 1;
		display: flex;
		flex-direction: column;
		max-width: 1200px;
		margin: 0 auto;
		width: 100%;
		padding: 0 1rem;
		gap: 2rem;
	}

	/* Practice Display */
	.practice-display {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 1rem;
		min-height: 400px;
	}

	.panel {
		background: rgba(255, 255, 255, 0.05);
		border-radius: 16px;
		border: 1px solid rgba(255, 255, 255, 0.1);
		overflow: hidden;
		transition: all 0.3s ease;
	}

	.panel-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 1rem 1.5rem;
		background: rgba(0, 0, 0, 0.3);
		border-bottom: 1px solid rgba(255, 255, 255, 0.1);
	}

	.panel-header h3 {
		margin: 0;
		font-size: 1.1rem;
		font-weight: 600;
		color: #4ecdc4;
	}

	.panel-toggle {
		background: none;
		border: none;
		color: rgba(255, 255, 255, 0.6);
		cursor: pointer;
		padding: 0.5rem;
		border-radius: 6px;
		transition: all 0.2s ease;
	}

	.panel-toggle:hover {
		background: rgba(255, 255, 255, 0.1);
		color: #ffffff;
	}

	.panel-content {
		padding: 1.5rem;
	}

	.notation-panel {
		flex: 0 0 35%;
	}

	.lyrics-panel {
		flex: 1;
	}

	.notation-content, .lyrics-content {
		font-size: clamp(1.1rem, 2.5vw, 1.4rem);
		line-height: 1.6;
		text-align: center;
		min-height: 3rem;
		display: flex;
		flex-direction: column;
		justify-content: center;
	}

	.current-lyric-line {
		font-weight: 600;
		color: #ffffff;
		margin-bottom: 1rem;
	}

	.upcoming-lyrics-preview {
		font-size: 0.9em;
		color: rgba(255, 255, 255, 0.6);
		line-height: 1.4;
	}

	.upcoming-lyrics-preview .lyric-line {
		margin: 0.5rem 0;
		opacity: 0.7;
		transition: all 0.3s ease;
	}

	/* Control Panel */
	.control-panel {
		display: flex;
		flex-direction: column;
		gap: 1.5rem;
		padding: 2rem 0;
	}

	.control-section {
		background: rgba(255, 255, 255, 0.05);
		border-radius: 12px;
		padding: 1.5rem;
		border: 1px solid rgba(255, 255, 255, 0.1);
	}

	.control-group {
		display: flex;
		align-items: center;
		gap: 1rem;
		flex-wrap: wrap;
	}

	.file-input-label {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.75rem 1.5rem;
		background: rgba(255, 255, 255, 0.1);
		border-radius: 8px;
		cursor: pointer;
		transition: all 0.2s ease;
		font-weight: 500;
	}

	.file-input-label:hover {
		background: rgba(255, 255, 255, 0.15);
		transform: translateY(-1px);
	}

	.primary-button {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.75rem 2rem;
		background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
		color: white;
		border: none;
		border-radius: 8px;
		font-weight: 600;
		cursor: pointer;
		transition: all 0.2s ease;
	}

	.primary-button:hover:not(:disabled) {
		transform: translateY(-2px);
		box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
	}

	.primary-button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	/* Transport Controls */
	.transport-controls {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 1rem;
		margin-bottom: 1.5rem;
	}

	.playback-controls {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 1.5rem;
	}

	.transport-button {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 60px;
		height: 60px;
		border-radius: 50%;
		border: none;
		background: rgba(255, 255, 255, 0.1);
		color: white;
		cursor: pointer;
		transition: all 0.2s ease;
	}

	.transport-button:hover {
		background: rgba(255, 255, 255, 0.2);
		transform: scale(1.05);
	}

	.play-button {
		background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
	}

	.play-button:hover {
		box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
	}

	.loop-label {
		font-weight: 600;
		color: #4ecdc4;
	}

	/* Progress Section */
	.progress-section {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.time-display {
		display: flex;
		justify-content: space-between;
		font-size: 0.9rem;
		color: rgba(255, 255, 255, 0.7);
		font-variant-numeric: tabular-nums;
	}

	.progress-container {
		position: relative;
		height: 8px;
		background: rgba(255, 255, 255, 0.1);
		border-radius: 4px;
		overflow: visible;
		cursor: pointer;
	}

	.progress-bar {
		position: relative;
		height: 100%;
	}

	.progress-fill {
		position: absolute;
		height: 100%;
		background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
		border-radius: 4px;
		width: 0%;
		transition: width 0.1s ease;
	}

	.timeline-markers {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 15;
		pointer-events: none;
	}

	.marker-line {
		position: absolute;
		width: 2px;
		height: 100%;
		background: #ffff00;
		top: 0;
		bottom: 0;
		box-shadow: 0 0 8px #ffff00, 0 0 16px rgba(255, 255, 0, 0.8);
		opacity: 1;
	}

	#seek-bar {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		cursor: pointer;
		z-index: 10;
	}

	.playhead-indicator {
		position: absolute;
		top: -12px;
		left: 0;
		color: #4ecdc4;
		transform: translateX(-50%);
		transition: left 0.1s ease;
		z-index: 10;
		cursor: grab;
		user-select: none;
	}

	.playhead-indicator:active {
		cursor: grabbing;
	}

	/* Practice Controls */
	.control-label {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-weight: 500;
		cursor: pointer;
	}

	.control-label input[type="checkbox"] {
		width: 18px;
		height: 18px;
		accent-color: #4ecdc4;
	}

	.count-in-controls {
		display: flex;
		align-items: center;
		gap: 0.75rem;
		padding: 0 0.5rem;
	}

	.bpm-label {
		color: rgba(255, 255, 255, 0.7);
		font-size: 0.9rem;
		white-space: nowrap;
	}

	.bpm-input {
		padding: 0.4rem 0.6rem;
		background: rgba(255, 255, 255, 0.1);
		border: 1px solid rgba(78, 205, 196, 0.3);
		border-radius: 4px;
		color: white;
		font-size: 0.9rem;
		width: 70px;
		transition: all 0.2s ease;
	}

	.bpm-input:focus {
		outline: none;
		border-color: #4ecdc4;
		background: rgba(78, 205, 196, 0.1);
	}

	#count-in-beats-dropdown {
		padding: 0.4rem 0.6rem;
		background: rgba(255, 255, 255, 0.1);
		border: 1px solid rgba(78, 205, 196, 0.3);
		border-radius: 4px;
		color: white;
		font-size: 0.9rem;
		cursor: pointer;
		min-width: 60px;
		transition: all 0.2s ease;
	}

	#count-in-beats-dropdown:hover:not(:disabled) {
		border-color: #4ecdc4;
		background: rgba(78, 205, 196, 0.1);
	}

	#count-in-beats-dropdown:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.count-in-square {
		min-width: 36px;
		min-height: 36px;
		padding: 0;
		display: flex;
		align-items: center;
		justify-content: center;
		border: 2px solid rgba(78, 205, 196, 0.5);
		transition: all 0.2s ease;
	}

	.count-in-square:hover:not(:disabled) {
		border-color: #4ecdc4;
		background: rgba(78, 205, 196, 0.2);
	}

	.count-in-square:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	#count-in-countdown {
		font-size: 5rem;
		font-weight: 900;
		color: #4ecdc4;
		text-align: center;
		line-height: 1;
		margin: 1rem 0;
		text-shadow: 0 0 20px rgba(78, 205, 196, 0.8);
		animation: pulse 0.2s ease-out;
	}

	@keyframes pulse {
		0% {
			transform: scale(1.1);
		}
		100% {
			transform: scale(1);
		}
	}

	#count-in-countdown.hidden {
		display: none;
	}

	.loop-controls {
		width: 100%;
		margin-top: 1rem;
	}

	.loop-section {
		background: rgba(78, 205, 196, 0.05) !important;
		border: 1px solid rgba(78, 205, 196, 0.2) !important;
		display: none !important;
	}

	.loop-section.enabled {
		display: block !important;
	}

	.loop-header {
		margin-bottom: 1rem;
	}

	.loop-visualizer {
		width: 100%;
		height: 30px;
		background: rgba(0, 0, 0, 0.3);
		border-radius: 6px;
		position: relative;
		border: 1px solid rgba(255, 255, 255, 0.2);
	}

	.loop-track {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.loop-markers {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		z-index: 15;
		pointer-events: none;
		overflow: visible;
	}

	.loop-marker-line {
		position: absolute;
		width: 4px;
		height: 100%;
		background: #00ff00 !important;
		top: 0;
		bottom: 0;
		box-shadow: 0 0 12px #00ff00, 0 0 24px rgba(0, 255, 0, 1);
		opacity: 1 !important;
		display: block !important;
		visibility: visible !important;
		transition: all 0.1s ease;
	}

	.loop-marker-line.snapped {
		width: 6px;
		background: #ffff00 !important;
		box-shadow: 0 0 16px #ffff00, 0 0 32px rgba(255, 255, 0, 1) !important;
	}

	.loop-area {
		position: absolute;
		top: 0;
		height: 100%;
		background: rgba(78, 205, 196, 0.2);
		border-left: 2px solid #4ecdc4;
		border-right: 2px solid #4ecdc4;
	}

	.loop-handle {
		position: absolute;
		top: 0;
		width: 20px;
		height: 100%;
		cursor: ew-resize;
		display: flex;
		align-items: center;
		justify-content: center;
		transform: translateX(-50%);
		z-index: 20;
	}

	.loop-grip {
		background: #4ecdc4;
		color: #000;
		font-weight: bold;
		font-size: 0.8rem;
		width: 16px;
		height: 16px;
		border-radius: 50%;
		display: flex;
		align-items: center;
		justify-content: center;
		cursor: ew-resize;
		transition: all 0.2s ease;
	}

	.loop-grip:hover {
		transform: scale(1.2);
	}

	/* Advanced Controls */
	.control-row {
		display: flex;
		gap: 2rem;
		margin-bottom: 1.5rem;
		flex-wrap: wrap;
	}

	.slider-group {
		display: flex;
		align-items: center;
		gap: 0.5rem;
	}

	.adjust-button {
		width: 32px;
		height: 32px;
		border-radius: 50%;
		border: none;
		background: rgba(255, 255, 255, 0.1);
		color: white;
		cursor: pointer;
		display: flex;
		align-items: center;
		justify-content: center;
		transition: all 0.2s ease;
	}

	.adjust-button:hover {
		background: rgba(255, 255, 255, 0.2);
	}

	.value-display {
		min-width: 3rem;
		text-align: center;
		font-weight: 600;
		color: #4ecdc4;
		font-variant-numeric: tabular-nums;
	}

	.reset-button {
		width: 24px;
		height: 24px;
		font-size: 0.8rem;
	}

	#volume {
		flex: 1;
		max-width: 200px;
		height: 6px;
		background: rgba(255, 255, 255, 0.1);
		border-radius: 3px;
		outline: none;
		-webkit-appearance: none;
	}

	#volume::-webkit-slider-thumb {
		-webkit-appearance: none;
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background: #4ecdc4;
		cursor: pointer;
	}

	/* Responsive Design */
	@media (max-width: 768px) {
		.studio-main {
			padding: 0 0.5rem;
			gap: 1rem;
		}

		.studio-header {
			padding: 1rem;
		}

		.control-section {
			padding: 1rem;
		}

		.control-group {
			flex-direction: column;
			align-items: stretch;
			gap: 0.75rem;
		}

		.transport-controls {
			gap: 0.75rem;
		}

		.transport-button {
			width: 50px;
			height: 50px;
		}

		.control-row {
			flex-direction: column;
			gap: 1rem;
		}

		.song-details {
			flex-direction: column;
			gap: 0.5rem;
		}
	}

	@media (max-width: 480px) {
		.studio-title {
			font-size: 2rem;
		}

		.panel-content {
			padding: 1rem;
		}

		.transport-button {
			width: 45px;
			height: 45px;
		}

		.primary-button {
			padding: 0.6rem 1.5rem;
			font-size: 0.9rem;
		}
	}

	/* Utility Classes */
	.hidden {
		display: none !important;
	}

	/* Animations */
	@keyframes fadeIn {
		from {
			opacity: 0;
			transform: translateY(-10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	.panel {
		animation: fadeIn 0.3s ease-out;
	}
</style>

<script>
	import * as Tone from 'tone';

	// Force reload on iOS Chrome to clear fetch cache
	if (!sessionStorage.getItem("reloaded")) {
		sessionStorage.setItem("reloaded", "true");
		location.reload(true);
	}

	// console.log('Practice Studio loaded');

	// State variables
	let audio: HTMLAudioElement | null = null;
	let currentAudioFileName = '';
	let isPlaying = false;
	let pitchShift = 0; // in semitones
	let playbackSpeed = 1.0;
	let isIntentionalStop = false; // Flag to distinguish pause from stop
	
	// Count-in state
	let isCountingIn = false;
	let countInActive = false;
	let countInIntervalId: number | undefined = undefined;
	let beatDurationMs = 0; // Will be set from CSLP edupu, or falls back to this value if not set

	// Tone.js nodes for independent pitch and speed
	let tonePlayer: Tone.Player | null = null;
	let pitchShifter: Tone.PitchShift | null = null;
	let toneGain: Tone.Gain | null = null;
	let isUsingTone = false;
	let toneNow: number = 0;
	let rafId: number = 0;
	let playStartTime: number = 0; // Wall clock time when play started

	// DOM elements
	const audioFileInput = document.getElementById('audio-file') as HTMLInputElement;
	const loadButton = document.getElementById('load-button') as HTMLButtonElement;
	const playPauseBtn = document.getElementById('play-pause') as HTMLButtonElement;
	const stopBtn = document.getElementById('stop') as HTMLButtonElement;
	const seekBar = document.getElementById('seek-bar') as HTMLInputElement;
	const currentTimeDisplay = document.getElementById('current-time') as HTMLSpanElement;
	const durationDisplay = document.getElementById('duration') as HTMLSpanElement;
	const progressFill = document.getElementById('progress-fill') as HTMLDivElement;
	const volumeControl = document.getElementById('volume') as HTMLInputElement;
	const currentLyricDisplay = document.getElementById('current-lyric') as HTMLDivElement;
	const practiceDisplay = document.getElementById('practice-display') as HTMLDivElement;
	const advancedControls = document.getElementById('advanced-controls') as HTMLDivElement;
	const countInButton = document.getElementById('count-in-button') as HTMLButtonElement;
	const countInBeatsDropdown = document.getElementById('count-in-beats-dropdown') as HTMLSelectElement;
	const countInCountdown = document.getElementById('count-in-countdown') as HTMLSpanElement;
	const loopEnable = document.getElementById('loop-enable') as HTMLInputElement;
	const loopControls = document.getElementById('loop-controls') as HTMLDivElement;
	const speedDisplay = document.getElementById('speed-display') as HTMLSpanElement;
	const pitchDisplay = document.getElementById('pitch-display') as HTMLSpanElement;

	// Cache frequently accessed DOM elements
	const playheadIndicator = document.querySelector('.playhead-indicator') as HTMLElement;
	const progressContainer = document.querySelector('.progress-container') as HTMLElement;

	// Handle URL parameter for auto-loading song
	async function activatePlayPanel() {
		// Show practice display and controls
		practiceDisplay.classList.remove('hidden');
		
		// Show all new sections
		const progressSection = document.getElementById('progress-section') as HTMLDivElement;
		const loopSection = document.getElementById('loop-section') as HTMLDivElement;
		const playbackControlsSection = document.querySelector('.playback-controls-section') as HTMLDivElement;
		
		if (progressSection) progressSection.classList.remove('hidden');
		if (loopSection) loopSection.classList.remove('hidden');
		if (playbackControlsSection) playbackControlsSection.classList.remove('hidden');
		
		advancedControls.classList.remove('hidden');

		// Hide file input section
		const fileInputSection = document.getElementById('file-inputs-section') as HTMLDivElement;
		fileInputSection.classList.add('hidden');

		// Initialize Tone.js for independent pitch and speed control
		await initializeToneJS();

		// Try to load CSLP file for display
		await loadCSLPData();
	}

	async function loadSongFromParameter() {
		const urlParams = new URLSearchParams(window.location.search);
		const songParam = urlParams.get('song');
		
		if (songParam) {
			currentAudioFileName = songParam;
			// Load from GitHub raw URL
			const audioUrl = `https://raw.githubusercontent.com/mandobala/mandolinbalajipwa/main/public/mysource/${encodeURIComponent(songParam)}.mp3`;
			// console.log('üéµ Loading MP3 from:', audioUrl);
			
			try {
				if (audio) {
					audio.pause();
					if (audio.src.startsWith('blob:')) {
						URL.revokeObjectURL(audio.src);
					}
				}
				
				audio = new Audio(audioUrl);
				audio.volume = parseInt(volumeControl.value) / 100;
				
				audio.addEventListener('loadedmetadata', async () => {
					if (!audio!.duration || isNaN(audio!.duration) || audio!.duration === Infinity) {
						alert('Invalid audio file. Unable to read file duration.');
						return;
					}
					
					durationDisplay.textContent = formatTime(audio!.duration);
					seekBar.max = audio!.duration.toString();
					loadButton.disabled = false;
					
					// Regenerate markers if CSLP data is already loaded
					if (cslpData && cslpData.data.timeline) {
						generateTimelineMarkers(cslpData.data.timeline, audio!.duration);
						generateLoopMarkers(cslpData.data.timeline, audio!.duration);
						initializeLoopHandles(cslpData.data.timeline, audio!.duration);
					}
					
					// Trigger the load button click automatically
					loadButton.click();
				});
				
				// Load CSLP data for this song
				await loadCSLPData();
			} catch (error) {
				// console.error('Error loading song from parameter:', error);
				currentLyricDisplay.textContent = 'üéµ Ready to practice';
			}
		}
	}

	// Audio file selection
	audioFileInput.addEventListener('change', (e) => {
		const file = (e.target as HTMLInputElement).files?.[0];
		if (file) {
			const validAudioTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/m4a'];
			const fileExtension = file.name.toLowerCase().split('.').pop();
			const validExtensions = ['mp3', 'wav', 'ogg', 'm4a', 'aac'];

			if (!validAudioTypes.includes(file.type) && !validExtensions.includes(fileExtension || '')) {
				alert('Invalid audio file. Please select a valid audio file.');
				audioFileInput.value = '';
				return;
			}

			const url = URL.createObjectURL(file);
			if (audio) {
				audio.pause();
				URL.revokeObjectURL(audio.src);
			}

			audio = new Audio(url);
			audio.volume = parseInt(volumeControl.value) / 100;
			currentAudioFileName = file.name.replace(/\.[^/.]+$/, '');

			audio.addEventListener('loadedmetadata', () => {
				if (!audio!.duration || isNaN(audio!.duration) || audio!.duration === Infinity) {
					alert('Invalid audio file. Unable to read file duration.');
					URL.revokeObjectURL(url);
					audioFileInput.value = '';
					return;
				}

				durationDisplay.textContent = formatTime(audio!.duration);
				seekBar.max = audio!.duration.toString();
				loadButton.disabled = false;
				
				// Regenerate markers if CSLP data is already loaded
				if (cslpData && cslpData.data.timeline) {
					generateTimelineMarkers(cslpData.data.timeline, audio!.duration);
					generateLoopMarkers(cslpData.data.timeline, audio!.duration);
					initializeLoopHandles(cslpData.data.timeline, audio!.duration);
				}
				
				// console.log('Audio file ready:', currentAudioFileName);
			});

			// Note: We'll use RAF for Tone.js playback progress, not timeupdate
			audio.addEventListener('ended', () => {
				isPlaying = false;
				updatePlayPauseButton();
			});

			// console.log('Audio file selected:', currentAudioFileName);
		}
	});

	// Load button handler
	loadButton.addEventListener('click', async () => {
		if (!audio) return;
		await activatePlayPanel();
	});

	// State for CSLP data
	let cslpData: any = null;

	// Load CSLP file and display data
	async function loadCSLPData() {
		// console.log(`üîç currentAudioFileName raw value: "${currentAudioFileName}"`);
		// console.log(`üîç currentAudioFileName type: ${typeof currentAudioFileName}`);
		// console.log(`üîç currentAudioFileName length: ${currentAudioFileName.length}`);
		// console.log(`üîç currentAudioFileName charCodes: ${Array.from(currentAudioFileName).map(c => c.charCodeAt(0)).join(',')}`);
		
		const cslpUrl = `/LyricsTagged/${encodeURIComponent(currentAudioFileName)}.cslp`;
		// console.log(`üîç Audio file name: "${currentAudioFileName}"`);
		// console.log(`üîç Looking for CSLP file at: ${cslpUrl}`);
		
		try {
			const response = await fetch(cslpUrl);
			// console.log(`   Response status: ${response.status} ${response.statusText}`);
			
			if (!response.ok) {
				// console.log(`‚ùå CSLP file not found (${response.status}), using default display`);
				currentLyricDisplay.textContent = 'üéµ Ready to practice';
				return;
			}

			cslpData = await response.json();
			// console.log(`‚úÖ CSLP file found and loaded successfully`);
			// console.log('üìù CSLP Data:', cslpData);

			// Extract metadata
			const metadata = cslpData.data.metadata;
			const timeline = cslpData.data.timeline;

			// Display song metadata in header
			const songMetadata = document.getElementById('song-metadata') as HTMLDivElement;
			const songTitle = document.getElementById('song-title') as HTMLDivElement;
			const ragamText = document.getElementById('ragam-text') as HTMLDivElement;
			const talamText = document.getElementById('talam-text') as HTMLDivElement;
			const shrutiText = document.getElementById('shruti-text') as HTMLDivElement;
			const arohanamText = document.getElementById('arohanam-text') as HTMLDivElement;
			const avarohanamText = document.getElementById('avarohanam-text') as HTMLDivElement;

			if (metadata) {
				// Limit title to 20 characters
				const titleDisplay = (metadata.title || 'Unknown Song').substring(0, 20);
				if (songTitle) songTitle.textContent = titleDisplay;
				if (ragamText) ragamText.textContent = metadata.ragam || '';
				if (talamText) talamText.textContent = metadata.talam || '';
				if (shrutiText) shrutiText.textContent = metadata.shruti || '';
				if (arohanamText) arohanamText.textContent = metadata.aarohanam || '';
				if (avarohanamText) avarohanamText.textContent = metadata.avarohanam || '';
			
			// Extract edupu value for count-in beat timing (in milliseconds)
			// Higher edupu values = slower beats (inverse relationship)
			// edupu is typically a musical time unit, so we interpret higher values as slower timing
			
			// Try to convert edupu to number if it exists
			let edupuValue = null;
			if (metadata?.edupu !== undefined && metadata?.edupu !== null) {
				edupuValue = typeof metadata.edupu === 'number' ? metadata.edupu : parseInt(metadata.edupu, 10);
			}
			
			if (edupuValue && !isNaN(edupuValue) && edupuValue > 0) {
				beatDurationMs = edupuValue;
			}
			
			songMetadata.classList.remove('hidden');
		}			// Generate timeline markers (if duration is available)
			// If duration not available yet, markers will be regenerated when audio metadata loads
			if (audio && audio.duration && !isNaN(audio.duration)) {
				generateTimelineMarkers(timeline, audio.duration);
				generateLoopMarkers(timeline, audio.duration);
				initializeLoopHandles(timeline, audio.duration);
				// console.log('‚úÖ Markers generated with duration:', audio.duration);
			} else {
				// console.log('‚è≥ Duration not yet available, markers will generate after audio loads');
			}

			// Display initial lyrics and notation
			updateLyricsAndNotation(0);

			// Show notation panel
			if ((window as any).showNotationPanel) {
				(window as any).showNotationPanel();
			}

			// console.log('‚úÖ CSLP loaded successfully');
			// console.log('  Title:', metadata.title);
			// console.log('  Raagam:', metadata.ragam);
			// console.log('  Talam:', metadata.talam);
			// console.log('  Timeline entries:', timeline.length);
		} catch (error) {
			// console.error(`‚ö†Ô∏è Error loading CSLP file:`, error);
			// CSLP file load failed - continue with fallback
			if (currentLyricDisplay) {
				currentLyricDisplay.textContent = 'üéµ Ready to practice';
			}
		}
	}

	// Find the current timeline entry based on time
	function getCurrentTimelineEntry(currentTime: number) {
		if (!cslpData || !cslpData.data.timeline) return null;
		
		const timeline = cslpData.data.timeline;
		let currentEntry = null;
		
		// Find the entry that matches or is just before the current time
		for (let i = timeline.length - 1; i >= 0; i--) {
			if (timeline[i].time <= currentTime) {
				currentEntry = timeline[i];
				break;
			}
		}
		
		return currentEntry;
	}

	// Update lyrics and notation based on current time
	function updateLyricsAndNotation(currentTime: number) {
		if (!cslpData || !cslpData.data.timeline) return;

		const timeline = cslpData.data.timeline;
		const currentEntry = getCurrentTimelineEntry(currentTime);

		// Helper: transform notation HTML by rewriting bare-filename img src to /LyricsImages/<mp3Base>/...
		function transformNotationHtml(html: string) {
			if (!html) return '';
			const wrapper = document.createElement('div');
			wrapper.innerHTML = html;
			const imgs = wrapper.querySelectorAll('img');
			imgs.forEach((img) => {
				const srcAttr = img.getAttribute('src') || '';
				if (!/^(?:https?:|\/|data:)/i.test(srcAttr)) {
					let mp3FileName = (cslpData && cslpData.data && cslpData.data.mp3FileName) ? cslpData.data.mp3FileName : currentAudioFileName || '';
					if (mp3FileName) {
						const mp3Base = mp3FileName.replace(/\.[^/.]+$/, '');
						const localPath = `/LyricsImages/${mp3Base}/${srcAttr}`;
						img.setAttribute('src', `${localPath}?v=${Date.now()}`);
					}
				}
				img.onerror = function() {
					try {
						this.onerror = null;
						const parent = this.parentElement;
						if (parent) parent.textContent = 'notation not found';
					} catch (e) {}
				};
			});
			return wrapper.innerHTML;
		}

		function applyNotationHtmlToDisplay(html: string, notationDisplay: HTMLDivElement) {
			const transformed = transformNotationHtml(html);
			const temp = document.createElement('div');
			temp.innerHTML = transformed;
			const newImg = temp.querySelector('img');
			const existingImg = notationDisplay.querySelector('img');
			if (newImg) {
				if (existingImg) {
					const newSrc = newImg.getAttribute('src') || '';
					const existingSrc = existingImg.getAttribute('src') || '';
					if (newSrc !== existingSrc) {
						existingImg.setAttribute('src', newSrc);
						existingImg.onerror = newImg.onerror;
					}
					notationDisplay.textContent = '';
					notationDisplay.appendChild(existingImg);
				} else {
					notationDisplay.innerHTML = '';
					notationDisplay.appendChild(newImg);
				}
			} else {
				notationDisplay.textContent = temp.textContent || 'No notation';
			}
		}

		if (currentEntry) {
			// Update current lyric
			if (currentLyricDisplay) {
				currentLyricDisplay.textContent = currentEntry.text || 'üéµ';
			}

			// Update notation using shared helpers
			const notationDisplay = document.getElementById('current-notation') as HTMLDivElement;
			if (notationDisplay) {
				if (currentEntry.notation && /<img\b/i.test(currentEntry.notation)) {
					applyNotationHtmlToDisplay(currentEntry.notation, notationDisplay);
				} else {
					notationDisplay.textContent = currentEntry.notation || 'No notation';
				}
			}

			// Update upcoming lyrics - using safe DOM manipulation
			const upcomingLyricsDiv = document.getElementById('upcoming-lyrics') as HTMLDivElement;
			if (upcomingLyricsDiv) {
				const currentIndex = timeline.indexOf(currentEntry);
				const upcomingEntries = timeline.slice(currentIndex + 1, currentIndex + 4);
				
				// Clear existing content
				upcomingLyricsDiv.textContent = '';
				
				// Safely append new elements
				upcomingEntries.forEach((entry: any) => {
					try {
						const div = document.createElement('div');
						div.className = 'lyric-line';
						div.style.margin = '0.5rem 0';
						div.style.opacity = '0.6';
						div.textContent = entry.text;
						upcomingLyricsDiv.appendChild(div);
					} catch (e) {
						// Continue if element creation fails
					}
				});
			}
		} else if (timeline.length > 0) {
			// Before first entry
			const firstEntry = timeline[0];
			if (currentLyricDisplay) {
				currentLyricDisplay.textContent = firstEntry.text || 'üéµ';
			}
			
			const notationDisplay = document.getElementById('current-notation') as HTMLDivElement;
			if (notationDisplay) {
				if (firstEntry.notation && /<img\b/i.test(firstEntry.notation)) {
					applyNotationHtmlToDisplay(firstEntry.notation, notationDisplay);
				} else {
					notationDisplay.textContent = firstEntry.notation || 'No notation';
				}
			}

			const upcomingLyricsDiv = document.getElementById('upcoming-lyrics') as HTMLDivElement;
			if (upcomingLyricsDiv) {
				const upcomingEntries = timeline.slice(1, 4);
				
				// Clear existing content
				upcomingLyricsDiv.textContent = '';
				
				// Safely append new elements
				upcomingEntries.forEach((entry: any) => {
					try {
						const div = document.createElement('div');
						div.className = 'lyric-line';
						div.style.margin = '0.5rem 0';
						div.style.opacity = '0.6';
						div.textContent = entry.text;
						upcomingLyricsDiv.appendChild(div);
					} catch (e) {
						// Continue if element creation fails
					}
				});
			}
		}
	}

	// Initialize Tone.js for independent pitch and speed control
	async function initializeToneJS() {
		if (!audio) return;

		try {
			// Start Tone.js audio context
			await Tone.start();

			// Create Tone.js Player
			tonePlayer = new Tone.Player({
				url: audio.src,
				loop: false,
				autostart: false
			}).toDestination();

			// Wait for player to load
			await Tone.loaded();

			// Create pitch shifter (independent of speed)
			pitchShifter = new Tone.PitchShift(pitchShift);

			// Create gain node
			toneGain = new Tone.Gain(parseInt(volumeControl.value) / 100);

			// Connect: Player -> PitchShift -> Gain -> Destination
			tonePlayer.disconnect();
			tonePlayer.chain(pitchShifter, toneGain, Tone.Destination);

			// Set initial playback rate for speed
			tonePlayer.playbackRate = playbackSpeed;

			// Set up event handler for playback end (only fires on explicit stop)
			tonePlayer.onstop = () => {
				// Only process if this is a true stop (not pause)
				if (isIntentionalStop) {
					isIntentionalStop = false; // Reset flag
					isPlaying = false;
					if (rafId) cancelAnimationFrame(rafId);
					// console.log('‚èπÔ∏è Playback stopped');
				}
				// Ignore if this is just a pause
			};

			isUsingTone = true;
			// console.log('‚úÖ Tone.js initialized - independent pitch/speed control enabled');

		} catch (error) {
			// Tone.js initialization failed - using Web Audio fallback
			isUsingTone = false;
			alert('Failed to initialize audio system. Please refresh the page.');
		}
	}

	// Pitch control handlers
	const pitchDownBtn = document.getElementById('pitch-down') as HTMLButtonElement;
	const pitchUpBtn = document.getElementById('pitch-up') as HTMLButtonElement;
	const pitchResetBtn = document.getElementById('pitch-reset') as HTMLButtonElement;

	const speedDownBtn = document.getElementById('speed-down') as HTMLButtonElement;
	const speedUpBtn = document.getElementById('speed-up') as HTMLButtonElement;
	const speedResetBtn = document.getElementById('speed-reset') as HTMLButtonElement;

	if (pitchDownBtn) {
		pitchDownBtn.addEventListener('click', () => {
			if (pitchShift > -12) {
				pitchShift -= 0.5;
				updatePitchDisplay();
				applyPitchShift();
			}
		});
	}

	if (pitchUpBtn) {
		pitchUpBtn.addEventListener('click', () => {
			if (pitchShift < 12) {
				pitchShift += 0.5;
				updatePitchDisplay();
				applyPitchShift();
			}
		});
	}

	if (pitchResetBtn) {
		pitchResetBtn.addEventListener('click', () => {
			pitchShift = 0;
			updatePitchDisplay();
			applyPitchShift();
		});
	}

	if (speedDownBtn) {
		speedDownBtn.addEventListener('click', () => {
			if (playbackSpeed > 0.25) {
				playbackSpeed = Math.max(0.25, playbackSpeed - 0.1);
				updateSpeedDisplay();
				applySpeed();
			}
		});
	}

	if (speedUpBtn) {
		speedUpBtn.addEventListener('click', () => {
			if (playbackSpeed < 2.0) {
				playbackSpeed = Math.min(2.0, playbackSpeed + 0.1);
				updateSpeedDisplay();
				applySpeed();
			}
		});
	}

	if (speedResetBtn) {
		speedResetBtn.addEventListener('click', () => {
			playbackSpeed = 1.0;
			updateSpeedDisplay();
			applySpeed();
		});
	}

	function updatePitchDisplay() {
		const sign = pitchShift > 0 ? '+' : '';
		pitchDisplay.textContent = `${sign}${pitchShift.toFixed(1)}`;
	}

	function updateSpeedDisplay() {
		speedDisplay.textContent = `${playbackSpeed.toFixed(1)}x`;
	}

	function applyPitchShift() {
		if (!audio) return;

		if (isUsingTone && pitchShifter && tonePlayer) {
			// Compensate for pitch change caused by playbackRate
			const playbackPitchShift = 12 * Math.log2(playbackSpeed);
			const compensatedPitch = pitchShift - playbackPitchShift;
			pitchShifter.pitch = compensatedPitch;
			// console.log(`üéµ Pitch: ${pitchShift} semitones (compensated: ${compensatedPitch.toFixed(2)} for speed ${playbackSpeed}x)`);
		} else {
			// Fallback to HTML5 audio (pitch affects speed)
			if (pitchShift === 0) {
				audio.playbackRate = playbackSpeed;
				audio.preservesPitch = true;
			}
		}
	}

	function applySpeed() {
		if (!audio) return;

		if (isUsingTone && tonePlayer && pitchShifter) {
			// Tone.js: playbackRate affects pitch, so compensate
			tonePlayer.playbackRate = playbackSpeed;
			// Calculate pitch shift needed to compensate for playbackRate pitch change
			const playbackPitchShift = 12 * Math.log2(playbackSpeed);
			// Compensate by shifting pitch in opposite direction, then add user's desired pitch
			const compensatedPitch = pitchShift - playbackPitchShift;
			pitchShifter.pitch = compensatedPitch;
			// console.log(`‚ö° Speed: ${playbackSpeed}x, Pitch: ${pitchShift} semitones (compensated: ${compensatedPitch.toFixed(2)})`);
		} else {
			// Fallback to HTML5 audio
			if (pitchShift === 0) {
				audio.preservesPitch = true;
				audio.playbackRate = playbackSpeed;
				// console.log(`‚ö° Speed: ${playbackSpeed}x (pitch preserved)`);
			}
		}
	}

	// Generate timeline markers on progress bar
	function generateTimelineMarkers(timeline: any[], duration: number) {
		const markersContainer = document.getElementById('timeline-markers') as HTMLDivElement;
		if (!markersContainer) {
			// timeline-markers container not found - skip marker generation
			return;
		}

		// Clear existing markers
		markersContainer.innerHTML = '';

		// Create a marker for each timeline entry
		let markersCreated = 0;
		const samplePositions: any[] = [];
		timeline.forEach((entry: any, idx: number) => {
			if (entry.time >= 0 && entry.time <= duration) {
				const marker = document.createElement('div');
				marker.className = 'marker-line';
				const percentage = (entry.time / duration) * 100;
				marker.style.left = `${percentage}%`;
				markersContainer.appendChild(marker);
				markersCreated++;
				
				// Store sample positions for logging
				if (idx === 0 || idx === Math.floor(timeline.length / 2) || idx === timeline.length - 1) {
					samplePositions.push({ time: entry.time, percentage: percentage.toFixed(2) });
				}
			}
		});

		// console.log(`üìç Generated ${markersCreated} timeline markers out of ${timeline.length} entries`);
		// console.log(`  Duration: ${duration}s`);
		// console.log(`  Sample positions:`, samplePositions);
		// console.log(`  First marker DOM element:`, markersContainer.firstChild);
	}

	// Generate loop markers (same as timeline markers for loop track)
	function generateLoopMarkers(timeline: any[], duration: number) {
		const markersContainer = document.getElementById('loop-markers') as HTMLDivElement;
		if (!markersContainer) {
			// loop-markers container not found - skip marker generation
			return;
		}

		// Clear existing markers
		markersContainer.innerHTML = '';
		// console.log(`üéØ Starting to generate loop markers for ${timeline.length} entries, duration: ${duration}s`);

		// Pre-calculate styles to reduce repeated calculations
		const markerStyles = {
			position: 'absolute' as const,
			width: '4px',
			height: '100%',
			background: '#00ff00',
			top: '0',
			bottom: '0',
			boxShadow: '0 0 12px #00ff00, 0 0 24px rgba(0, 255, 0, 1)',
			opacity: '1',
			display: 'block' as const,
			visibility: 'visible' as const,
			zIndex: '15',
		};

		// Use document fragment for batch DOM insertion
		const fragment = document.createDocumentFragment();

		// Create a marker for each timeline entry
		let markersCreated = 0;
		timeline.forEach((entry: any, idx: number) => {
			if (entry.time >= 0 && entry.time <= duration) {
				const marker = document.createElement('div');
				marker.className = 'loop-marker-line';
				const percentage = (entry.time / duration) * 100;
				marker.style.left = `${percentage}%`;

				// Apply all styles at once
				Object.assign(marker.style, markerStyles);

				// Add detailed attributes for debugging
				marker.setAttribute('data-time', String(entry.time));
				marker.setAttribute('data-index', String(idx));

				fragment.appendChild(marker);
				if (markersCreated < 5) {
					console.log(`  ‚úì Marker ${markersCreated}: time=${entry.time}s, left=${percentage}%`);
				}
				markersCreated++;
			}
		});

		// Single DOM operation for all markers
		markersContainer.appendChild(fragment);

		// console.log(`üìç Generated ${markersCreated} loop markers out of ${timeline.length} entries`);
		// console.log(`üìä Container size: ${markersContainer.offsetWidth}x${markersContainer.offsetHeight}, Children: ${markersContainer.children.length}`);
	}	// Set loop handles to first and last marker positions
	function initializeLoopHandles(timeline: any[], duration: number) {
		if (!timeline || timeline.length === 0) return;

		const loopStartHandle = document.getElementById('loop-start-handle') as HTMLDivElement;
		const loopEndHandle = document.getElementById('loop-end-handle') as HTMLDivElement;
		const loopTrack = document.querySelector('.loop-track') as HTMLDivElement;

		if (!loopStartHandle || !loopEndHandle || !loopTrack) return;

		// Get first and last timeline entries
		const firstEntry = timeline[0];
		const lastEntry = timeline[timeline.length - 1];

		// Calculate percentages
		const startPercentage = (firstEntry.time / duration) * 100;
		const endPercentage = (lastEntry.time / duration) * 100;

		// Set positions
		loopStartHandle.style.left = `${startPercentage}%`;
		loopEndHandle.style.left = `${endPercentage}%`;

		// Store loop times
		(window as any).loopStartTime = firstEntry.time;
		(window as any).loopEndTime = lastEntry.time;

		// console.log(`üìç Loop handles initialized: A=${startPercentage.toFixed(1)}%, B=${endPercentage.toFixed(1)}%`);
		updateLoopArea();
	}

	// Update loop area visual region
	function updateLoopArea() {
		const loopStartHandle = document.getElementById('loop-start-handle') as HTMLDivElement;
		const loopEndHandle = document.getElementById('loop-end-handle') as HTMLDivElement;
		const loopArea = document.getElementById('loop-area') as HTMLDivElement;

		if (!loopStartHandle || !loopEndHandle || !loopArea) return;

		const startLeft = parseFloat(loopStartHandle.style.left);
		const endLeft = parseFloat(loopEndHandle.style.left);

		// Ensure start is before end
		const minLeft = Math.min(startLeft, endLeft);
		const maxLeft = Math.max(startLeft, endLeft);

		loopArea.style.left = `${minLeft}%`;
		loopArea.style.width = `${maxLeft - minLeft}%`;
	}

	// Play/Pause button
	playPauseBtn.addEventListener('click', async () => {
		if (!isUsingTone || !tonePlayer || !audio) return;

		// If clicking during count-in, cancel the count-in
		if (isCountingIn) {
			clearInterval(countInIntervalId);
			countInIntervalId = undefined;
			isCountingIn = false;
			countInActive = false;
			countInCountdown.classList.add('hidden');
			updateCountInButtonState();
			updatePlayPauseButton();
			return;
		}

		try {
			const isPlayerRunning = tonePlayer.state === 'started';
			
			if (isPlayerRunning) {
				// PAUSE: Calculate current position and update toneNow
				const now = performance.now();
				const elapsedMs = now - playStartTime;
				const elapsedSeconds = elapsedMs / 1000;
				toneNow = toneNow + (elapsedSeconds * playbackSpeed);
				
				// Stop the player completely
				tonePlayer.stop(0); // Stop immediately with 0 fade
				if (rafId) cancelAnimationFrame(rafId);
				isPlaying = false;
				// console.log('‚è∏Ô∏è Paused at', toneNow.toFixed(2), 's');
			} else {
				// RESUME: Restart from paused position
				try {
					if (tonePlayer.state === 'started') {
						tonePlayer.stop(0);
					}
				} catch (e) {
					// Ignore
				}
				
				// Ensure audio context is running
				if (Tone.context.state !== 'running') {
					await Tone.start();
				}
				
				// Start playback from the paused position
				tonePlayer.start(0, toneNow);
				playStartTime = performance.now();
				
				isPlaying = true;
				startProgressTracking();
				// console.log('‚ñ∂Ô∏è Resumed from', toneNow.toFixed(2), 's');
			}
		} catch (e) {
			console.error('Play/pause failed:', e);
		}
		updatePlayPauseButton();
		updateCountInButtonState();
	})

	// Stop button
	stopBtn.addEventListener('click', () => {
		if (!isUsingTone || !tonePlayer) return;

		try {
			isIntentionalStop = true; // Signal that this is a real stop, not pause
			tonePlayer.stop();
			if (rafId) cancelAnimationFrame(rafId);
			toneNow = 0;
			isPlaying = false;
			currentTimeDisplay.textContent = '0:00';
			progressFill.style.width = '0%';
			seekBar.value = '0';
			if (playheadIndicator) playheadIndicator.style.left = 'calc(0% - 8px)';
			// console.log('‚èπÔ∏è Stopped');
		} catch (e) {
			console.error('Stop failed:', e);
		}
		updatePlayPauseButton();
		updateCountInButtonState();
	});

	// Count-in button
	countInButton.addEventListener('click', async () => {
		// Only allow count-in when not playing
		if (isPlaying || isCountingIn) return;

		try {
			const selectedBeats = parseInt(countInBeatsDropdown.value);
			const bpmInput = document.getElementById('count-in-bpm') as HTMLInputElement;
			const bpm = parseInt(bpmInput.value) || 120; // Default to 120 BPM
			
			isCountingIn = true;
			countInActive = true;
			countInButton.disabled = true;
			countInBeatsDropdown.disabled = true;
			bpmInput.disabled = true;

			// Start countdown
			let currentCount = selectedBeats;
			
			// Calculate beat duration from BPM: 60000ms per minute / BPM = ms per beat
			const currentBeatDuration = Math.round(60000 / bpm);

			// Display and play sounds for countdown
			// Each beat should display for currentBeatDuration milliseconds
			// We'll run the interval faster (every 10ms) to get smooth updates, but only show/play every (currentBeatDuration/10) ticks
			let tickCounter = 0;
			const ticksPerBeat = Math.max(1, Math.floor(currentBeatDuration / 10)); // How many 10ms ticks = 1 beat
			
			const countdownInterval = setInterval(async () => {
				// Check if it's time to show the next number (every ticksPerBeat ticks)
				if (tickCounter % ticksPerBeat === 0 && currentCount > 0) {
					// Display number
					countInCountdown.textContent = currentCount.toString();
					countInCountdown.classList.remove('hidden');

					// Play wood block sound
					try {
						const synth = new Tone.Synth({
							oscillator: { type: 'sine' },
							envelope: {
								attack: 0.002,
								decay: 0.05,
								sustain: 0,
								release: 0.03
							}
						}).toDestination();
						synth.triggerAttackRelease('C4', '0.1');
					} catch (e) {
						// console.log('Click sound failed:', e);
					}

					currentCount--;
				}
				
				tickCounter++;
				
				// Check if countdown is complete (when currentCount goes below 0 after showing all numbers)
				if (currentCount === 0 && tickCounter % ticksPerBeat === 0) {
					// Countdown finished, start playback
					clearInterval(countdownInterval);
					countInCountdown.classList.add('hidden');

					// Start audio playback from current position
					if (Tone.context.state !== 'running') {
						await Tone.start();
					}

					if (tonePlayer) {
						try {
							tonePlayer.start(0, toneNow);
							playStartTime = performance.now();
						} catch (e) {
							// console.log('Play after count-in failed:', e);
						}
					}

				isPlaying = true;
				isCountingIn = false;
				startProgressTracking();
				updatePlayPauseButton();
			}
		}, 10); // Run every 10ms for smooth timing			countInIntervalId = countdownInterval;
		} catch (e) {
			console.error('Count-in failed:', e);
			isCountingIn = false;
			countInButton.disabled = false;
			countInBeatsDropdown.disabled = false;
			countInCountdown.classList.add('hidden');
		}
	});

	// Update button states based on playback
	function updateCountInButtonState() {
		const bpmInput = document.getElementById('count-in-bpm') as HTMLInputElement;
		const canUseCountIn = !isPlaying && !isCountingIn;
		countInButton.disabled = !canUseCountIn;
		countInBeatsDropdown.disabled = !canUseCountIn;
		if (bpmInput) bpmInput.disabled = !canUseCountIn;
	}

	// Seek bar
	seekBar.addEventListener('input', () => {
		if (!isUsingTone || !tonePlayer) return;
		const newTime = parseFloat(seekBar.value);

		try {
			toneNow = newTime;
			if (isPlaying) {
				// Restart playback from new position
				tonePlayer.stop();
				if (rafId) cancelAnimationFrame(rafId);
				playStartTime = performance.now();
				tonePlayer.start(0, newTime);
				startProgressTracking();
			}
			// Update display immediately
			currentTimeDisplay.textContent = formatTime(newTime);
			const progress = (newTime / (audio?.duration || 1)) * 100;
			progressFill.style.width = `${progress}%`;
			if (playheadIndicator) playheadIndicator.style.left = `calc(${progress}% - 8px)`;
			// console.log('üîç Seeked to', newTime.toFixed(2), 's');
		} catch (e) {
			// Seek failed - continue anyway
		}
	});

	// Volume control
	volumeControl.addEventListener('input', () => {
		if (!isUsingTone || !toneGain) return;
		const volume = parseInt(volumeControl.value) / 100;
		toneGain.gain.value = volume;
		// console.log('üîä Volume:', (volume * 100).toFixed(0) + '%');
	});

	// Progress tracking with RAF for Tone.js
	function startProgressTracking() {
		let frameCount = 0;
		function updateFrame() {
			frameCount++;
			
			if (!isPlaying || !isUsingTone || !tonePlayer) {
				rafId = 0;
				return;
			}

			try {
				// Verify player is still in valid state before proceeding
				if (tonePlayer.state !== 'started') {
					// Player stopped unexpectedly
					isPlaying = false;
					if (rafId) cancelAnimationFrame(rafId);
					updatePlayPauseButton();
					return;
				}

				// Calculate elapsed time from when play started (wall clock time)
				const now = performance.now();
				const elapsedMs = now - playStartTime;
				const elapsedSeconds = elapsedMs / 1000;
				
				const loopEnable = document.getElementById('loop-enable') as HTMLInputElement;
				const loopStartTime = (window as any).loopStartTime || 0;
				const loopEndTime = (window as any).loopEndTime || audio?.duration || 0;

				// Calculate display time accounting for playback speed
				let displayTime = toneNow + (elapsedSeconds * playbackSpeed);
				
				// Safety check: ensure displayTime is valid (not NaN or Infinity)
				if (!isFinite(displayTime)) {
					displayTime = toneNow || 0;
				}

				// Additional safety: ensure displayTime doesn't go negative or exceed duration
				if (displayTime < 0) displayTime = 0;
				if (audio?.duration && displayTime > audio.duration) displayTime = audio.duration;

				// Auto-loop: Jump from B to A when reaching loop end
				if (loopEnable?.checked && displayTime >= loopEndTime && loopEndTime > 0) {
					tonePlayer.stop();
					toneNow = loopStartTime;
					playStartTime = performance.now();
					tonePlayer.start(0, loopStartTime);
					rafId = requestAnimationFrame(updateFrame);
					return;
				}

				// Stop at end of track
				if (displayTime >= (audio?.duration || 0)) {
					tonePlayer.stop();
					isPlaying = false;
					if (rafId) cancelAnimationFrame(rafId);
					updatePlayPauseButton();
					return;
				}

				// Throttle DOM updates to every 6 frames (~100ms at 60fps, ~170ms at 36fps on iOS)
				// This reduces the frequency of DOM manipulations that might cause crashes
				if (frameCount % 6 === 0) {
					// Update UI - with extra null checks
					try {
						if (currentTimeDisplay && typeof currentTimeDisplay.textContent !== 'undefined') {
							currentTimeDisplay.textContent = formatTime(displayTime);
						}
					} catch (e) {
						// Continue if currentTimeDisplay fails
					}

					try {
						if (seekBar && typeof seekBar.value !== 'undefined') {
							seekBar.value = displayTime.toString();
						}
					} catch (e) {
						// Continue if seekBar fails
					}

					try {
						if (progressFill && audio?.duration && isFinite(displayTime)) {
							const progress = Math.max(0, Math.min(100, (displayTime / audio.duration) * 100));
							if (typeof progressFill.style !== 'undefined') {
								progressFill.style.width = `${progress}%`;
							}
							if (playheadIndicator && typeof playheadIndicator.style !== 'undefined') {
								playheadIndicator.style.left = `calc(${progress}% - 8px)`;
							}
						}
					} catch (e) {
						// Continue if progress update fails
					}
				}

				// Update lyrics and notation (disabled but still called)
				updateLyricsAndNotation(displayTime);

				rafId = requestAnimationFrame(updateFrame);
			} catch (e) {
				// Critical error - stop playback
				isPlaying = false;
				if (rafId) cancelAnimationFrame(rafId);
				updatePlayPauseButton();
			}
		}
		rafId = requestAnimationFrame(updateFrame);
	}

	// Make playhead draggable for seeking (with touch support for mobile)
	let isDraggingPlayhead = false;

	function handlePlayheadDragStart(e: Event) {
		isDraggingPlayhead = true;
		(e as any).preventDefault?.();
	}

	function handlePlayheadDragMove(e: Event) {
		if (!isDraggingPlayhead || !progressContainer || !isUsingTone) return;

		const clientX = (e as MouseEvent).clientX || (e as TouchEvent).touches?.[0]?.clientX;
		if (clientX === undefined) return;

		const rect = progressContainer.getBoundingClientRect();
		const x = clientX - rect.left;
		const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
		const newTime = (percentage / 100) * (audio?.duration || 1);

		toneNow = newTime;
		seekBar.value = newTime.toString();
		currentTimeDisplay.textContent = formatTime(newTime);
		progressFill.style.width = `${percentage}%`;
		if (playheadIndicator) playheadIndicator.style.left = `calc(${percentage}% - 8px)`;
	}

	function handlePlayheadDragEnd() {
		if (isDraggingPlayhead && isUsingTone && tonePlayer && isPlaying) {
			// Resume playback from new position
			tonePlayer.stop();
			if (rafId) cancelAnimationFrame(rafId);
			playStartTime = performance.now();
			tonePlayer.start(0, toneNow);
			startProgressTracking();
		}
		isDraggingPlayhead = false;
	}

	// Attach playhead drag listeners (desktop + mobile) - ONCE
	if (playheadIndicator && progressContainer) {
		// Mouse events
		playheadIndicator.addEventListener('mousedown', handlePlayheadDragStart);
		window.addEventListener('mousemove', handlePlayheadDragMove);
		window.addEventListener('mouseup', handlePlayheadDragEnd);

		// Touch events for mobile
		playheadIndicator.addEventListener('touchstart', handlePlayheadDragStart, { passive: false });
		window.addEventListener('touchmove', handlePlayheadDragMove, { passive: false });
		window.addEventListener('touchend', handlePlayheadDragEnd);
	}

	// Loop handle dragging with snap-to-marker functionality
	let isDraggingLoopStart = false;
	let isDraggingLoopEnd = false;
	let currentAudioDuration = 0;

	function findNearestMarker(clientX: number, markerElements: Element[]): { time: number; position: number } | null {
		if (!progressContainer || markerElements.length === 0) return null;

		const rect = progressContainer.getBoundingClientRect();
		const x = clientX - rect.left;
		const percentage = (x / rect.width) * 100;
		const snapDistance = 5; // 5% snap distance

		let nearest: { time: number; position: number } | null = null;
		let minDistance = snapDistance;

		for (const marker of markerElements) {
			const markerRect = marker.getBoundingClientRect();
			const markerLeft = markerRect.left - rect.left;
			const markerPercentage = (markerLeft / rect.width) * 100;
			const distance = Math.abs(percentage - markerPercentage);

			if (distance < minDistance) {
				minDistance = distance;
				const timeStr = marker.getAttribute('data-time');
				const markerTime = timeStr ? parseFloat(timeStr) : 0;
				nearest = { time: markerTime, position: markerPercentage };
			}
		}

		return nearest;
	}

	function handleLoopStartDragStart(e: Event) {
		isDraggingLoopStart = true;
		(e as any).preventDefault?.();
	}

	function handleLoopStartDragMove(e: Event) {
		if (!isDraggingLoopStart || !audio || !progressContainer) return;

		const clientX = (e as MouseEvent).clientX || (e as TouchEvent).touches?.[0]?.clientX;
		if (clientX === undefined) return;

		const loopStartHandle = document.getElementById('loop-start-handle') as HTMLDivElement;
		if (!loopStartHandle) return;

		// Get all markers
		const markers = Array.from(document.querySelectorAll('.loop-marker-line'));

		// Find nearest marker
		const nearest = findNearestMarker(clientX, markers);

		if (nearest) {
			// Snap to marker
			loopStartHandle.style.left = `${nearest.position}%`;
			(window as any).loopStartTime = nearest.time;

			// Highlight snapped marker
			markers.forEach(m => m.classList.remove('snapped'));
			const snappedMarker = markers.find(m => m.getAttribute('data-time') === nearest.time.toString());
			if (snappedMarker) snappedMarker.classList.add('snapped');

			// Update loop area visual
			updateLoopArea();

			// console.log(`üìå Loop start snapped to: ${nearest.time.toFixed(2)}s at ${nearest.position.toFixed(1)}%`);
		}
	}

	function handleLoopStartDragEnd() {
		isDraggingLoopStart = false;

		// Remove highlight
		document.querySelectorAll('.loop-marker-line.snapped').forEach(m => m.classList.remove('snapped'));
	}

	function handleLoopEndDragStart(e: Event) {
		isDraggingLoopEnd = true;
		(e as any).preventDefault?.();
	}

	function handleLoopEndDragMove(e: Event) {
		if (!isDraggingLoopEnd || !audio || !progressContainer) return;

		const clientX = (e as MouseEvent).clientX || (e as TouchEvent).touches?.[0]?.clientX;
		if (clientX === undefined) return;

		const loopEndHandle = document.getElementById('loop-end-handle') as HTMLDivElement;
		if (!loopEndHandle) return;

		// Get all markers
		const markers = Array.from(document.querySelectorAll('.loop-marker-line'));

		// Find nearest marker
		const nearest = findNearestMarker(clientX, markers);

		if (nearest) {
			// Snap to marker
			loopEndHandle.style.left = `${nearest.position}%`;
			(window as any).loopEndTime = nearest.time;

			// Highlight snapped marker
			markers.forEach(m => m.classList.remove('snapped'));
			const snappedMarker = markers.find(m => m.getAttribute('data-time') === nearest.time.toString());
			if (snappedMarker) snappedMarker.classList.add('snapped');

			// Update loop area visual
			updateLoopArea();

			// console.log(`üìå Loop end snapped to: ${nearest.time.toFixed(2)}s at ${nearest.position.toFixed(1)}%`);
		}
	}

	function handleLoopEndDragEnd() {
		isDraggingLoopEnd = false;

		// Remove highlight
		document.querySelectorAll('.loop-marker-line.snapped').forEach(m => m.classList.remove('snapped'));
	}

	// Attach loop handle drag listeners (desktop + mobile) - ONCE using window to avoid conflicts
	const loopStartHandle = document.getElementById('loop-start-handle');
	const loopEndHandle = document.getElementById('loop-end-handle');

	if (loopStartHandle && progressContainer) {
		// Mouse events
		loopStartHandle.addEventListener('mousedown', handleLoopStartDragStart);
		window.addEventListener('mousemove', handleLoopStartDragMove);
		window.addEventListener('mouseup', handleLoopStartDragEnd);

		// Touch events for mobile
		loopStartHandle.addEventListener('touchstart', handleLoopStartDragStart, { passive: false });
		window.addEventListener('touchmove', handleLoopStartDragMove, { passive: false });
		window.addEventListener('touchend', handleLoopStartDragEnd);
	}

	if (loopEndHandle && progressContainer) {
		// Mouse events
		loopEndHandle.addEventListener('mousedown', handleLoopEndDragStart);
		window.addEventListener('mousemove', handleLoopEndDragMove);
		window.addEventListener('mouseup', handleLoopEndDragEnd);

		// Touch events for mobile
		loopEndHandle.addEventListener('touchstart', handleLoopEndDragStart, { passive: false });
		window.addEventListener('touchmove', handleLoopEndDragMove, { passive: false });
		window.addEventListener('touchend', handleLoopEndDragEnd);
	}

	// Format time helper
	function formatTime(seconds: number): string {
		const mins = Math.floor(seconds / 60);
		const secs = Math.floor(seconds % 60);
		return `${mins}:${secs.toString().padStart(2, '0')}`;
	}

	// Update play/pause button appearance
	function updatePlayPauseButton() {
		const playIcon = playPauseBtn.querySelector('.play-icon') as HTMLElement;
		const pauseIcon = playPauseBtn.querySelector('.pause-icon') as HTMLElement;

		if (isPlaying) {
			playIcon?.classList.add('hidden');
			pauseIcon?.classList.remove('hidden');
		} else {
			playIcon?.classList.remove('hidden');
			pauseIcon?.classList.add('hidden');
		}
	}

	// Panel toggle functionality
	document.addEventListener('DOMContentLoaded', () => {
		// Check for URL parameter and load song if present
		loadSongFromParameter();
		
		const panelToggles = document.querySelectorAll('.panel-toggle');

		panelToggles.forEach(toggle => {
			toggle.addEventListener('click', () => {
				const panelType = (toggle as HTMLElement).dataset.panel;
				const panel = document.getElementById(`${panelType}-panel`);

				if (panel) {
					const isHidden = panel.classList.contains('hidden');
					if (isHidden) {
						panel.classList.remove('hidden');
						toggle.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18,15 12,9 6,15"></polyline></svg>';
					} else {
						panel.classList.add('hidden');
						toggle.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6,9 12,15 18,9"></polyline></svg>';
					}
				}
			});
		});

		// Show notation panel by default when CSLP data loads
		const showNotationPanel = () => {
			const notationPanel = document.getElementById('notation-panel') as HTMLDivElement;
			if (notationPanel) {
				notationPanel.classList.remove('hidden');
				// Set toggle to show down arrow (open state)
				const toggle = notationPanel.querySelector('.panel-toggle') as HTMLElement;
				if (toggle) {
					toggle.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18,15 12,9 6,15"></polyline></svg>';
				}
			}
		};

		// Make showNotationPanel available globally so loadCSLPData can call it
		(window as any).showNotationPanel = showNotationPanel;

		// Loop controls toggle
		if (loopEnable && loopControls) {
			loopEnable.addEventListener('change', () => {
				const loopSection = document.getElementById('loop-section') as HTMLDivElement;
				if (loopEnable.checked) {
					loopControls.classList.remove('hidden');
					if (loopSection) {
						loopSection.classList.remove('hidden');
						loopSection.classList.add('enabled');
					}
				} else {
					loopControls.classList.add('hidden');
					if (loopSection) {
						loopSection.classList.remove('enabled');
						loopSection.classList.add('hidden');
					}
				}
			});
		}

		// Speed controls
		const speedDownBtn = document.getElementById('speed-down') as HTMLButtonElement;
		const speedUpBtn = document.getElementById('speed-up') as HTMLButtonElement;
		const speedResetBtn = document.getElementById('speed-reset') as HTMLButtonElement;
		let playbackSpeed = 1.0;

		speedDownBtn?.addEventListener('click', () => {
			if (playbackSpeed > 0.25) {
				playbackSpeed = Math.max(0.25, playbackSpeed - 0.1);
				if (audio) audio.playbackRate = playbackSpeed;
				speedDisplay.textContent = `${playbackSpeed.toFixed(1)}x`;
			}
		});

		speedUpBtn?.addEventListener('click', () => {
			if (playbackSpeed < 2.0) {
				playbackSpeed = Math.min(2.0, playbackSpeed + 0.1);
				if (audio) audio.playbackRate = playbackSpeed;
				speedDisplay.textContent = `${playbackSpeed.toFixed(1)}x`;
			}
		});

		speedResetBtn?.addEventListener('click', () => {
			playbackSpeed = 1.0;
			if (audio) audio.playbackRate = playbackSpeed;
			speedDisplay.textContent = '1.0x';
		});

		// Pitch controls
		const pitchDownBtn = document.getElementById('pitch-down') as HTMLButtonElement;
		const pitchUpBtn = document.getElementById('pitch-up') as HTMLButtonElement;
		const pitchResetBtn = document.getElementById('pitch-reset') as HTMLButtonElement;
		let pitchShift = 0;

		pitchDownBtn?.addEventListener('click', () => {
			if (pitchShift > -12) {
				pitchShift -= 0.5;
				pitchDisplay.textContent = `${pitchShift.toFixed(1)}`;
				applyPitchShift(pitchShift);
			}
		});

		pitchUpBtn?.addEventListener('click', () => {
			if (pitchShift < 12) {
				pitchShift += 0.5;
				pitchDisplay.textContent = `${pitchShift > 0 ? '+' : ''}${pitchShift.toFixed(1)}`;
				applyPitchShift(pitchShift);
			}
		});

		pitchResetBtn?.addEventListener('click', () => {
			pitchShift = 0;
			pitchDisplay.textContent = '0';
			applyPitchShift(pitchShift);
		});

		function applyPitchShift(semitones: number) {
			if (!audio) return;
			if (semitones === 0) {
				audio.preservesPitch = true;
				audio.playbackRate = playbackSpeed;
			} else {
				const pitchRatio = Math.pow(2, semitones / 12);
				audio.preservesPitch = false;
				audio.playbackRate = pitchRatio;
			}
		}

		// console.log('Practice Studio fully initialized');
	});
</script>