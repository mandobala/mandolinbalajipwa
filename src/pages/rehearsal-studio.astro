---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout
	title="Rehearsal Studio | Mandolin Balaji"
	description="Practice with synchronized lyrics"
>
	<div class="rehearsal-container">
		<header>
			<h1 class="hero-title">Rehearsal Studio</h1>
			<p class="hero-tagline">Practice with time-synced lyrics</p>
			<div id="song-metadata" class="song-metadata hidden">
				<div id="song-title" class="song-title"></div>
				<div id="song-raaga" class="song-raaga">
					<span id="arohanam-label" class="metadata-label">Aroh:</span>
					<span id="arohanam-text" class="metadata-text"></span>
					<span id="avarohanam-label" class="metadata-label">Ava:</span>
					<span id="avarohanam-text" class="metadata-text"></span>
				</div>
			</div>
		</header>

		<!-- Display Area (75% height) - Split between Notation and Lyrics -->
		<div id="main-display" class="main-display hidden">
			<!-- Notation Display (Top Half) - Hidden by default -->
			<div id="notation-display" class="notation-display hidden">
				<div class="notation-container">
					<div id="current-notation" class="current-notation">
						<!-- Notation will appear here -->
					</div>
				</div>
			</div>
			
			<!-- Lyrics Display (Bottom Half) -->
			<div id="lyrics-display" class="lyrics-display">
				<div class="lyric-container">
					<div id="current-lyric" class="current-lyric">
						Select audio file to begin
					</div>
					<div id="upcoming-lyrics" class="upcoming-lyrics">
					</div>
				</div>
			</div>
		</div>

		<!-- File Loading Section -->
		<div id="file-inputs-wrapper" class="file-inputs-wrapper">
			<div class="controls-section">
					<div class="input-group">
						<label for="audio-file">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M9 18V5l12-2v13"></path>
								<circle cx="6" cy="18" r="3"></circle>
								<circle cx="18" cy="16" r="3"></circle>
							</svg>
							Load Audio (MP3)
						</label>
						<input type="file" id="audio-file" accept="audio/mp3,audio/mpeg" />
					</div>
				<button id="load-button" class="load-button" disabled>
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<path d="M5 12h14"/>
						<path d="M12 5l7 7-7 7"/>
					</svg>
					Load
				</button>

				<!-- Count-in and Loop Controls (inside controls-section) -->
				<div id="count-in-control" class="count-in-control hidden">
					<label class="checkbox-label">
						<input type="checkbox" id="count-in-enable" />
						<span>Count-in:</span>
					</label>
					<select id="count-in-beats" disabled>
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="3">3</option>
						<option value="4" selected>4</option>
					</select>
					<label class="checkbox-label loop-label">
						<input type="checkbox" id="loop-enable" />
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M17 1l4 4-4 4"/>
							<path d="M3 11V9a4 4 0 0 1 4-4h14"/>
							<path d="M7 23l-4-4 4-4"/>
							<path d="M21 13v2a4 4 0 0 1-4 4H3"/>
						</svg>
					</label>
				</div>
			</div>
		</div>

		<!-- Controls Area (25% height at bottom) -->
		<div class="controls-area">
			<div id="audio-player" class="audio-player hidden">
					<div class="waveform-container">
						<div class="playhead-indicator">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M7 10l5 5 5-5z"/>
							</svg>
						</div>
						<div class="time-display">
							<span id="current-time">0:00</span>
							<span id="duration">0:00</span>
						</div>
						<div class="progress-wrapper">
							<div class="progress-bar">
								<div id="progress-fill" class="progress-fill"></div>
								<input type="range" id="seek-bar" min="0" max="100" value="0" step="0.1" />
							</div>
							<div class="markers-track">
								<div id="lyric-markers" class="lyric-markers"></div>
							</div>
							<div id="loop-track" class="loop-track hidden">
								<div id="loop-region" class="loop-region">
									<div id="loop-start-handle" class="loop-handle loop-start">
										<div class="loop-line"></div>
										<div class="loop-grip">â‹®</div>
									</div>
									<div class="loop-area"></div>
									<div id="loop-end-handle" class="loop-handle loop-end">
										<div class="loop-line"></div>
										<div class="loop-grip">â‹®</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<div class="player-controls">
						<button id="play-pause" class="control-btn primary">
							<svg class="play-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
								<path d="M8 5v14l11-7z"/>
							</svg>
							<svg class="pause-icon hidden" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
								<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
							</svg>
						</button>
					<button id="stop" class="control-btn">
						<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
							<rect x="6" y="6" width="12" height="12"/>
						</svg>
					</button>

					<div class="pitch-control">
						<button id="pitch-down" class="control-btn-small" title="Lower pitch by half-step">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M19 12H5M12 19l-7-7 7-7"/>
							</svg>
						</button>
						<span id="pitch-display" class="control-display">0</span>
						<button id="pitch-up" class="control-btn-small" title="Raise pitch by half-step">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M5 12h14M12 5l7 7-7 7"/>
							</svg>
						</button>
						<button id="pitch-reset" class="control-btn-tiny" title="Reset pitch">â†º</button>
					</div>
					<div class="speed-control">
						<button id="speed-down" class="control-btn-small" title="Slow down">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M12 5v14M5 12l7 7 7-7"/>
							</svg>
						</button>
						<span id="speed-display" class="control-display">1.0x</span>
						<button id="speed-up" class="control-btn-small" title="Speed up">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M12 19V5M5 12l7-7 7 7"/>
							</svg>
						</button>
						<button id="speed-reset" class="control-btn-tiny" title="Reset speed">â†º</button>
					</div>
					<div class="volume-control">
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
							<path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
							<path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
						</svg>
						<input type="range" id="volume" min="0" max="100" value="80" />
					</div>
				</div>

				<!-- Count-in Button Row (separate section below play/stop on mobile) -->
				<div id="count-in-button-row" class="count-in-button-row hidden">
					<label for="count-in-bpm" class="bpm-label">BPM:</label>
					<input type="number" id="count-in-bpm" class="bpm-input" min="40" max="300" value="120" />
					<label for="count-in-beats-dropdown" class="beats-label">Beats:</label>
					<select id="count-in-beats-dropdown" class="beats-dropdown">
						<option value="4" selected>4</option>
						<option value="5">5</option>
						<option value="6">6</option>
						<option value="7">7</option>
						<option value="8">8</option>
						<option value="9">9</option>
						<option value="10">10</option>
					</select>
					<button id="count-in-button" class="count-in-button" title="Click to start count-in">â–¶</button>
					<div id="count-in-countdown" class="count-in-countdown hidden"></div>
				</div>

			</div>
		</div>

		<!-- Count-in and Loop Controls (outside controls-area) -->
		</div>
	</div>
</BaseLayout>

<style>
	.rehearsal-container {
		display: flex;
		flex-direction: column;
		height: 100vh;
		max-height: 100vh;
		overflow: hidden;
		background: #000;
		padding: 0;
		max-width: 600px;
		margin: 0 auto;
		box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
	}

	header {
		padding: 0.5rem 1rem;
		background: #0a0a0a;
		border-bottom: 1px solid #222;
	}

	.hero-title {
		font-size: var(--text-sm);
		color: var(--gray-0);
		line-height: 1.2;
		margin: 0 0 0.125rem 0;
		font-weight: 600;
	}

	.hero-tagline {
		color: var(--gray-400);
		font-size: var(--text-xs);
		margin: 0 0 0.5rem 0;
	}

	.song-metadata {
		margin-top: 0.5rem;
	}

	.song-title {
		color: var(--accent-regular);
		font-size: var(--text-sm);
		font-weight: 600;
		margin-bottom: 0.25rem;
	}

	.song-raaga {
		display: flex;
		flex-direction: column;
		gap: 0.125rem;
	}

	.metadata-label {
		color: var(--gray-300);
		font-size: var(--text-xs);
		font-weight: 500;
		min-width: 2.5rem;
		display: inline-block;
	}

	.metadata-text {
		color: var(--gray-100);
		font-size: var(--text-xs);
		font-family: 'Courier New', monospace;
		margin-left: 0.25rem;
	}

	/* Main Display Area - 75% split between notation and lyrics */
	.main-display {
		flex: 1 1 auto;
		min-height: 0;
		display: flex;
		flex-direction: column;
		background: #000;
		overflow: hidden;
	}

	/* Notation Display - Top Half */
	.notation-display {
		flex: 0 0 calc(33.75% + 37.5px); /* Reduced by 25% from previous size */
		display: flex;
		align-items: center;
		justify-content: center;
		border-bottom: 1px solid #222;
		overflow-y: auto;
		padding: 1rem;
	}

	.notation-container {
		width: 100%;
		max-width: 800px;
		text-align: center;
	}

	.current-notation {
		font-size: clamp(1rem, 3vw, 1.5rem);
		color: var(--accent-regular);
		font-weight: 600;
		line-height: 1.4;
		font-family: monospace;
		white-space: pre-wrap;
		min-height: 1.5rem;
		word-wrap: break-word;
		overflow-wrap: break-word;
		max-width: 100%;
		padding: 0 0.5rem;
	}

	/* Lyrics Display - Bottom Half */
	.lyrics-display {
		flex: 0 0 calc(56.25% - 37.5px); /* Increased to compensate for notation reduction */
		display: flex;
		align-items: center;
		justify-content: center;
		overflow-y: auto;
		padding: 1rem;
	}

	.lyric-container {
		width: 100%;
		max-width: 800px;
		text-align: center;
	}

	.current-lyric {
		font-size: clamp(1rem, 3vw, 1.5rem);
		color: var(--gray-0);
		font-weight: 600;
		line-height: 1.4;
		margin-bottom: 1rem;
		min-height: 1.5rem;
		word-wrap: break-word;
		overflow-wrap: break-word;
		word-break: break-word;
		hyphens: auto;
		max-width: 100%;
		padding: 0 0.5rem;
	}

	.upcoming-lyrics {
		font-size: clamp(0.875rem, 2.5vw, 1.125rem);
		color: var(--gray-500);
		line-height: 1.4;
		word-wrap: break-word;
		overflow-wrap: break-word;
	}

	/* Controls Area - 25% */
	.controls-area {
		flex: 0 0 auto;
		display: flex;
		flex-direction: column;
		background: #0a0a0a;
		border-top: 1px solid #222;
		overflow-y: auto;
		max-height: 40vh;
	}

	.file-inputs-wrapper {
		flex: 0 0 auto;
		background: #0a0a0a;
		border-bottom: 1px solid #222;
		transition: all 0.3s ease;
	}

	.file-inputs-wrapper.collapsed {
		display: none;
	}

	.controls-section {
		background: var(--gray-999);
		border: 1px solid var(--gray-800);
		border-radius: 0.5rem;
		padding: 0.5rem;
		margin: 0.5rem;
	}

	.file-inputs {
		display: flex;
		flex-direction: column;
		gap: 0.4rem;
	}

	.count-in-control {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.25rem 1rem; /* Reduced top/bottom padding to move up closer */
		background: #0a0a0a;
		border-bottom: 1px solid #222;
		flex-wrap: nowrap;
		font-size: var(--text-xs);
	}
	
	.loop-label {
		margin-left: auto;
	}
	
	.loop-label svg {
		color: var(--accent-regular);
		width: 18px;
		height: 18px;
	}

	.checkbox-label {
		display: flex;
		align-items: center;
		gap: 0.375rem;
		cursor: pointer;
		color: var(--gray-200);
		font-size: var(--text-xs);
		user-select: none;
		white-space: nowrap;
	}

	.checkbox-label input[type="checkbox"] {
		width: 16px;
		height: 16px;
		cursor: pointer;
		accent-color: var(--accent-regular);
	}

	#count-in-beats {
		padding: 0.25rem 0.375rem;
		background: var(--gray-800);
		border: 1px solid var(--gray-700);
		border-radius: 0.25rem;
		color: var(--gray-200);
		font-size: var(--text-xs);
		cursor: pointer;
		min-width: 45px;
	}

	#count-in-beats:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.input-group {
		display: flex;
		flex-direction: column;
		gap: 0.2rem;
	}

	.input-group label {
		display: flex;
		align-items: center;
		gap: 0.25rem;
		font-weight: 600;
		color: var(--gray-200);
		cursor: pointer;
		font-size: clamp(0.7rem, 1.8vw, 0.8rem);
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.input-group label svg {
		width: 12px;
		height: 12px;
		flex-shrink: 0;
	}

	.file-input-wrapper {
		position: relative;
		display: flex;
		align-items: center;
		gap: 0.4rem;
	}

	.input-group input[type="file"] {
		padding: 0.3rem 0.4rem;
		background: var(--gray-900);
		border: 1px dashed var(--gray-700);
		border-radius: 0.3rem;
		color: var(--gray-200);
		cursor: pointer;
		font-size: clamp(0.65rem, 1.6vw, 0.75rem);
		flex: 1;
		min-width: 0;
	}

	.input-group input[type="file"]:hover {
		border-color: var(--accent-regular);
	}

	.server-download-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 26px;
		height: 26px;
		background: var(--accent-regular);
		border: none;
		border-radius: 0.3rem;
		color: var(--gray-0);
		cursor: pointer;
		transition: all 0.2s;
		animation: pulse-download 2s ease-in-out infinite;
		flex-shrink: 0;
	}

	.server-download-btn:hover {
		background: var(--accent-dark);
		transform: translateY(-2px);
	}

	@keyframes pulse-download {
		0%, 100% {
			box-shadow: 0 0 0 0 rgba(var(--accent-regular-rgb), 0.7);
		}
		50% {
			box-shadow: 0 0 0 8px rgba(var(--accent-regular-rgb), 0);
		}
	}

	.load-button {
		display: flex;
		align-items: center;
		justify-content: center;
		gap: 0.3rem;
		padding: 0.4rem 0.8rem;
		background: var(--accent-regular);
		color: var(--gray-0);
		border: none;
		border-radius: 0.3rem;
		font-size: clamp(0.75rem, 2vw, 0.875rem);
		font-weight: 600;
		cursor: pointer;
		transition: all 0.2s;
		margin-top: 0.4rem;
		width: 100%;
	}

	.load-button svg {
		width: 14px;
		height: 14px;
	}

	.load-button:hover:not(:disabled) {
		background: var(--accent-dark);
	}

	.load-button:disabled {
		background: var(--gray-800);
		color: var(--gray-500);
		cursor: not-allowed;
		opacity: 0.6;
	}

	.audio-player {
		padding: 0.5rem; /* Reduced padding to move up closer */
	}

	.waveform-container {
		margin-bottom: 0.5rem;
		position: relative;
	}

	.playhead-indicator {
		position: absolute;
		top: -16px;
		left: 0;
		color: var(--accent-regular);
		transition: left 0.1s linear;
		z-index: 10;
		filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
	}

	.playhead-indicator svg {
		width: 12px;
		height: 12px;
	}

	.time-display {
		display: flex;
		justify-content: space-between;
		margin-bottom: 0.375rem;
		font-size: var(--text-xs);
		color: var(--gray-400);
		font-variant-numeric: tabular-nums;
	}

	.progress-wrapper {
		display: flex;
		flex-direction: column;
		gap: 0;
	}

	.progress-bar {
		position: relative;
		height: 6px;
		background: var(--gray-800);
		border-radius: 3px;
		overflow: hidden;
	}

	.markers-track {
		position: relative;
		height: 16px;
		background: #1a1a1a;
		border: 1px solid var(--gray-800);
		border-top: none;
	}

	.loop-track {
		position: relative;
		height: 24px;
		background: #0a0a0a;
		border: 1px solid var(--gray-800);
		border-top: none;
		border-radius: 0 0 3px 3px;
	}

	.loop-region {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.loop-handle {
		position: absolute;
		top: 0;
		width: 16px;
		height: 100%;
		cursor: ew-resize;
		z-index: 20;
		display: flex;
		align-items: center;
		justify-content: center;
		transform: translateX(-50%);
	}

	.loop-handle:hover {
		opacity: 0.8;
	}

	.loop-handle:active {
		opacity: 1;
	}

	.loop-start {
		left: 10%;
	}

	.loop-end {
		left: 90%;
	}

	.loop-line {
		position: absolute;
		top: 0;
		left: 50%;
		transform: translateX(-50%);
		width: 2px;
		height: 100%;
		background: var(--accent-regular);
		box-shadow: 0 0 6px var(--accent-regular);
	}

	.loop-grip {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		font-size: 1rem;
		color: var(--accent-regular);
		text-shadow: 0 0 3px var(--accent-regular);
		user-select: none;
	}

	.loop-area {
		position: absolute;
		top: 0;
		height: 100%;
		background: var(--accent-regular);
		opacity: 0.2;
		pointer-events: none;
	}

	.lyric-markers {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
	}

	.lyric-marker {
		position: absolute;
		top: 0;
		width: 3px;
		height: 100%;
		background: #888;
		transform: translateX(-50%);
		transition: all 0.2s;
		border-radius: 1px;
	}

	.lyric-marker.active {
		background: var(--accent-regular);
		width: 4px;
		box-shadow: 0 0 8px var(--accent-regular);
		z-index: 5;
	}

	.progress-fill {
		position: absolute;
		height: 100%;
		background: var(--accent-regular);
		border-radius: 4px;
		width: 0%;
		transition: width 0.1s linear;
	}

	#seek-bar {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		cursor: pointer;
		z-index: 15;
	}

	#seek-bar::-webkit-slider-thumb {
		width: 16px;
		height: 16px;
		cursor: pointer;
	}

	@media (max-width: 768px) {
		#seek-bar::-webkit-slider-thumb {
			width: 44px;
			height: 44px;
		}
	}

	.player-controls {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		flex-wrap: wrap;
		padding: 0.5rem 0;
	}

	.control-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 36px;
		height: 36px;
		border: none;
		border-radius: 50%;
		background: var(--gray-800);
		color: var(--gray-0);
		cursor: pointer;
		transition: all 0.2s;
	}

	.control-btn svg {
		width: 16px;
		height: 16px;
	}

	.control-btn:hover {
		background: var(--gray-700);
	}

	.control-btn.primary {
		background: var(--accent-regular);
		width: 44px;
		height: 44px;
	}

	.control-btn.primary svg {
		width: 20px;
		height: 20px;
	}

	.control-btn.primary:hover {
		background: var(--accent-dark);
	}

	.pitch-control,
	.speed-control {
		display: flex;
		align-items: center;
		gap: 0.25rem;
		padding: 0.375rem 0.5rem;
		background: var(--gray-900);
		border-radius: 0.375rem;
	}

	.control-btn-small {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 28px;
		height: 28px;
		border: none;
		border-radius: 0.25rem;
		background: var(--gray-800);
		color: var(--gray-0);
		cursor: pointer;
		transition: all 0.2s;
	}

	.control-btn-small svg {
		width: 14px;
		height: 14px;
	}

	.control-btn-small:hover {
		background: var(--accent-regular);
	}

	.control-btn-tiny {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 24px;
		height: 24px;
		border: none;
		border-radius: 0.25rem;
		background: var(--gray-700);
		color: var(--gray-300);
		cursor: pointer;
		transition: all 0.2s;
		font-size: 0.875rem;
	}

	.control-btn-tiny:hover {
		background: var(--gray-600);
		color: var(--gray-0);
	}

	.control-display {
		font-size: var(--text-xs);
		font-weight: 600;
		color: var(--accent-regular);
		min-width: 2rem;
		text-align: center;
		font-variant-numeric: tabular-nums;
	}

	.volume-control {
		display: flex;
		align-items: center;
		gap: 0.375rem;
		margin-left: auto;
		color: var(--gray-300);
	}

	.volume-control svg {
		width: 16px;
		height: 16px;
	}

	.volume-control input[type="range"] {
		width: 80px;
	}

	input[type="range"] {
		-webkit-appearance: none;
		appearance: none;
		background: var(--gray-800);
		border-radius: 4px;
		height: 6px;
		outline: none;
	}

	input[type="range"]::-webkit-slider-thumb {
		-webkit-appearance: none;
		appearance: none;
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background: var(--accent-regular);
		cursor: pointer;
	}

	input[type="range"]::-moz-range-thumb {
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background: var(--accent-regular);
		cursor: pointer;
		border: none;
	}

	.count-in-controls {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
		padding: 0.75rem 1rem;
		background: #0a0a0a;
		border-top: 1px solid #222;
	}

	.count-in-row {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		flex-wrap: wrap;
		justify-content: center;
		width: 100%;
	}

	.count-in-button-row {
		display: flex;
		align-items: center;
		gap: 0.375rem;
		flex-wrap: wrap;
		justify-content: flex-start;
		width: 100%;
		margin-top: 0.5rem;
	}

	.bpm-label,
	.beats-label {
		font-size: var(--text-xs);
		color: var(--gray-300);
		font-weight: 600;
		white-space: nowrap;
	}

	.bpm-input,
	.beats-dropdown {
		padding: 0.375rem 0.5rem;
		background: var(--gray-800);
		border: 1px solid var(--gray-700);
		border-radius: 0.25rem;
		color: var(--gray-200);
		font-size: var(--text-xs);
		cursor: pointer;
	}

	.bpm-input {
		width: 60px;
	}

	.bpm-input:disabled,
	.beats-dropdown:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.count-in-button {
		padding: 0.5rem 1rem;
		background: var(--accent-regular);
		color: #000;
		border: none;
		border-radius: 0.375rem;
		font-weight: 700;
		cursor: pointer;
		font-size: var(--text-xs);
		white-space: nowrap;
		transition: all 0.2s;
		box-shadow: 0 0 8px rgba(0, 255, 255, 0.3);
		min-width: 45px;
	}

	.count-in-button:hover:not(:disabled) {
		opacity: 0.9;
		box-shadow: 0 0 12px rgba(0, 255, 255, 0.6);
		transform: scale(1.05);
	}

	.count-in-button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
		box-shadow: none;
	}

	.count-in-countdown {
		font-size: 5rem;
		color: #00ffff;
		text-align: center;
		font-weight: bold;
		text-shadow: 0 0 20px #00ffff;
		animation: pulse 0.5s ease-in-out;
	}

	.count-in-countdown.hidden {
		display: none;
	}

	@keyframes pulse {
		0%, 100% {
			transform: scale(1);
			opacity: 1;
		}
		50% {
			transform: scale(1.1);
			opacity: 0.8;
		}
	}

	.lyrics-display {
		background: var(--gradient-subtle);
		border: 1px solid var(--gray-800);
		border-radius: 1rem;
		padding: 2rem;
		min-height: 300px;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
	}

	@media (max-width: 768px) {
		.lyrics-display {
			padding: 1rem;
			min-height: 200px;
			max-height: 40vh;
			overflow-y: auto;
		}
	}

	.lyric-container {
		display: flex;
		align-items: flex-start;
		gap: 1rem;
		width: 100%;
		max-width: 700px;
	}

	.upcoming-lyrics .lyric-line {
		display: block;
		margin: 0.75rem 0;
		opacity: 0.6;
		transition: all 0.3s;
	}

	.hidden {
		display: none !important;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
			transform: translateY(-10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	@media (max-width: 768px) {
		.player-controls {
			gap: 0.375rem;
			flex-wrap: wrap;
		}

		.pitch-control,
		.speed-control {
			gap: 0.25rem;
			padding: 0.25rem 0.375rem;
			display: none;
		}

		.volume-control {
			margin-left: 0;
			width: 100%;
			justify-content: center;
			display: none;
		}

		.volume-control input[type="range"] {
			flex: 1;
			max-width: 200px;
		}

		.count-in-button-row {
			gap: 0.25rem;
			width: 100%;
			margin-top: 0.5rem;
			padding: 0.5rem;
			background: var(--gray-900);
			border-radius: 0.375rem;
			justify-content: center;
		}

		.count-in-controls {
			padding: 0.5rem;
		}

		.count-in-row {
			gap: 0.375rem;
			justify-content: center;
		}

		.bpm-input {
			width: 45px;
		}

		.bpm-label,
		.beats-label {
			font-size: 0.6rem;
		}

		.count-in-button {
			padding: 0.375rem 0.625rem;
			font-size: 0.65rem;
		}

		.count-in-countdown {
			font-size: 2.5rem;
		}

		.lyric-container {
			flex-direction: column;
			align-items: center;
		}

		.lyric-indicator {
			transform: rotate(90deg);
			margin-top: 0;
			margin-bottom: 0.5rem;
		}

		.lyric-content {
			text-align: center;
		}

		.current-lyric {
			margin-bottom: 1rem;
			min-height: 2rem;
		}

		.count-in-control {
			gap: 0.5rem;
		}

		.loop-handle {
			width: 44px;
		}
	}
</style>

<script>
	import * as Tone from 'tone';
	
	let audio: HTMLAudioElement | null = null;
	let lyrics: Array<{ time: number; text: string }> = [];
	let notation: Array<{ time: number; text: string }> = [];
	let currentLyricIndex = -1;
	let currentNotationIndex = -1;
	let countInBeats = 0;
	let audioLoaded = false;
	let lyricsLoaded = false;
	let notationLoaded = false;
	let loopEnabled = false;
	let loopStart = 0;
	let loopEnd = 0;
	
	// CSLP metadata
	let songTitle = '';
	let aarohanam = '';
	let avarohanam = '';
	let isDraggingLoop = false;
	let currentDragHandle: 'start' | 'end' | null = null;
	let pitchShift = 0; // in semitones
	let playbackSpeed = 1.0;
	
	// Tone.js nodes for independent pitch and speed
	let tonePlayer: Tone.Player | null = null;
	let pitchShifter: Tone.PitchShift | null = null;
	let toneGain: Tone.Gain | null = null;
	let isUsingTone = false;
	let rafId: number = 0;
	let lastSeekTime = 0; // Track actual playback position
	let playbackStartTime = 0; // Track when playback started
	
	let wasPlayingBeforeSeek = false;

	const audioFileInput = document.getElementById('audio-file') as HTMLInputElement;
	const fileInputsSection = document.getElementById('file-inputs-wrapper') as HTMLDivElement;
	const loadButton = document.getElementById('load-button') as HTMLButtonElement;
	
	let currentAudioFileName = '';
	const audioPlayer = document.getElementById('audio-player') as HTMLDivElement;
	const lyricsDisplay = document.getElementById('lyrics-display') as HTMLDivElement;
	const notationDisplay = document.getElementById('notation-display') as HTMLDivElement;
	const currentNotationDisplay = document.getElementById('current-notation') as HTMLDivElement;
	const playPauseBtn = document.getElementById('play-pause') as HTMLButtonElement;
	const stopBtn = document.getElementById('stop') as HTMLButtonElement;
	const seekBar = document.getElementById('seek-bar') as HTMLInputElement;
	const volumeControl = document.getElementById('volume') as HTMLInputElement;
	const currentTimeDisplay = document.getElementById('current-time') as HTMLSpanElement;
	const durationDisplay = document.getElementById('duration') as HTMLSpanElement;
	const progressFill = document.getElementById('progress-fill') as HTMLDivElement;
	const currentLyricDisplay = document.getElementById('current-lyric') as HTMLDivElement;
	const upcomingLyricsDisplay = document.getElementById('upcoming-lyrics') as HTMLDivElement;
	const countInControl = document.getElementById('count-in-control') as HTMLDivElement;
	const countInEnable = document.getElementById('count-in-enable') as HTMLInputElement;
	const countInBeatsSelect = document.getElementById('count-in-beats') as HTMLSelectElement;
	const loopEnable = document.getElementById('loop-enable') as HTMLInputElement;
	const loopTrack = document.getElementById('loop-track') as HTMLDivElement;
	const loopStartHandle = document.getElementById('loop-start-handle') as HTMLDivElement;
	const loopEndHandle = document.getElementById('loop-end-handle') as HTMLDivElement;
	const loopArea = document.querySelector('.loop-area') as HTMLDivElement;
	const pitchDownBtn = document.getElementById('pitch-down') as HTMLButtonElement;
	const pitchUpBtn = document.getElementById('pitch-up') as HTMLButtonElement;
	const pitchResetBtn = document.getElementById('pitch-reset') as HTMLButtonElement;
	const pitchDisplay = document.getElementById('pitch-display') as HTMLSpanElement;
	const speedDownBtn = document.getElementById('speed-down') as HTMLButtonElement;
	const speedUpBtn = document.getElementById('speed-up') as HTMLButtonElement;
	const speedResetBtn = document.getElementById('speed-reset') as HTMLButtonElement;
	const speedDisplay = document.getElementById('speed-display') as HTMLSpanElement;
	const countInButtonRow = document.getElementById('count-in-button-row') as HTMLDivElement;
	const countInBpmInput = document.getElementById('count-in-bpm') as HTMLInputElement;
	const countInBeatsDropdown = document.getElementById('count-in-beats-dropdown') as HTMLSelectElement;
	const countInButton = document.getElementById('count-in-button') as HTMLButtonElement;
	const countInCountdown = document.getElementById('count-in-countdown') as HTMLDivElement;

	// Load audio file
	audioFileInput.addEventListener('change', (e) => {
		const file = (e.target as HTMLInputElement).files?.[0];
		if (file) {
			// Validate file type
			const validAudioTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/m4a', 'audio/aac'];
			const fileExtension = file.name.toLowerCase().split('.').pop();
			const validExtensions = ['mp3', 'wav', 'ogg', 'm4a', 'aac'];
			
			if (!validAudioTypes.includes(file.type) && !validExtensions.includes(fileExtension || '')) {
				alert('Invalid audio file. Please select a valid audio file (MP3, WAV, OGG, M4A, AAC).');
				audioFileInput.value = '';
				return;
			}
			
			// Check file size (limit to 100MB)
			const maxSize = 100 * 1024 * 1024; // 100MB in bytes
			if (file.size > maxSize) {
				alert('File is too large. Please select a file smaller than 100MB.');
				audioFileInput.value = '';
				return;
			}
			
			const url = URL.createObjectURL(file);
			if (audio) {
				audio.pause();
				URL.revokeObjectURL(audio.src);
			}
			audio = new Audio(url);
			audio.volume = parseInt(volumeControl.value) / 100;
			
			// Store audio filename and check for CSLP file
			currentAudioFileName = file.name.replace(/\.[^/.]+$/, ''); // Remove extension
			currentLyricDisplay.textContent = `ðŸŽµ ${currentAudioFileName}`;
			loadCSLPFile();
			
			// Add error handler for corrupted/invalid audio files
			audio.addEventListener('error', () => {
				alert('Unable to load audio file. The file may be corrupted or in an unsupported format.');
				URL.revokeObjectURL(url);
				audioFileInput.value = '';
				audioPlayer.classList.add('hidden');
			});
			
			audio.addEventListener('loadedmetadata', () => {
				// Additional validation - check if duration is valid
				if (!audio!.duration || isNaN(audio!.duration) || audio!.duration === Infinity) {
					alert('Invalid audio file. Unable to read file duration.');
					URL.revokeObjectURL(url);
					audioFileInput.value = '';
					return;
				}
				
			durationDisplay.textContent = formatTime(audio!.duration);
			seekBar.max = audio!.duration.toString();
			audioLoaded = true;
			// Enable load button when audio is ready
			loadButton.disabled = false;
			
			// Initialize Web Audio API for pitch shifting
			initializeAudioProcessing();
		});			audio.addEventListener('timeupdate', updateProgress);
			audio.addEventListener('ended', () => {
				playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
			});
			// Add play/pause state sync listeners for iOS compatibility
			audio.addEventListener('play', () => {
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			});
			audio.addEventListener('pause', () => {
				playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
			});
			audio.addEventListener('error', (e) => {
				console.error('Audio error:', e);
				// Reset button state on error
				playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
			});
		}
	});

	// Load CSLP file (JSON format with timeline)
	async function loadCSLPFile() {
		if (!currentAudioFileName) return;
		
		console.log('ðŸŽµ MP3 basename loaded:', currentAudioFileName);
		console.log('ðŸ” Looking for CSLP file basename:', currentAudioFileName);
		console.log('ðŸ“ Attempting to fetch CSLP file...');
		
		const cslpUrl = `/LyricsTagged/${encodeURIComponent(currentAudioFileName)}.cslp`;
		console.log('ðŸ”— Full CSLP file path:', cslpUrl);
		
		try {
			const response = await fetch(cslpUrl);
			if (!response.ok) {
				console.log('No CSLP file found for:', currentAudioFileName);
				currentLyricDisplay.textContent = 'No lyrics';
				lyricsDisplay.classList.remove('hidden');
				return;
			}
			
			const cslpData = await response.json();
			
			console.log('âœ… CSLP file found and loaded successfully:', currentAudioFileName);
			
			// Extract metadata
			if (cslpData.data.metadata) {
				songTitle = cslpData.data.metadata.title || '';
				aarohanam = cslpData.data.metadata.aarohanam || '';
				avarohanam = cslpData.data.metadata.avarohanam || '';
				console.log('ðŸ“Š CSLP metadata loaded:', { songTitle, aarohanam, avarohanam });
			}
			
			// Validate CSLP structure
			if (!cslpData.data || !cslpData.data.timeline || !Array.isArray(cslpData.data.timeline)) {
				console.log('Invalid CSLP file structure');
				currentLyricDisplay.textContent = 'No lyrics';
				lyricsDisplay.classList.remove('hidden');
				return;
			}
			
			// Parse timeline data
			const timeline = cslpData.data.timeline;
			lyrics = [];
			notation = [];
			
			for (const item of timeline) {
				if (item.time !== undefined && item.text) {
					lyrics.push({ time: item.time, text: item.text });
				}
				if (item.time !== undefined && item.notation) {
					notation.push({ time: item.time, text: item.notation });
				}
			}
			
			// Sort by time
			lyrics.sort((a, b) => a.time - b.time);
			notation.sort((a, b) => a.time - b.time);
			
			if (lyrics.length > 0) {
				lyricsDisplay.classList.remove('hidden');
				currentLyricDisplay.textContent = 'Lyrics loaded';
				displayUpcomingLyrics();
				lyricsLoaded = true;
			} else {
				currentLyricDisplay.textContent = 'No lyrics';
				lyricsDisplay.classList.remove('hidden');
			}
			
			if (notation.length > 0) {
				notationDisplay.classList.remove('hidden');
				notationLoaded = true;
				currentNotationDisplay.textContent = 'Notation ready';
			}
			
			// Update metadata display
			updateSongMetadata();
			
			console.log('CSLP file loaded successfully:', { lyricsCount: lyrics.length, notationCount: notation.length });
			
		} catch (error) {
			console.error('Error loading CSLP file:', error);
			currentLyricDisplay.textContent = 'No lyrics';
			lyricsDisplay.classList.remove('hidden');
		}
	}

	// Load button handler - show player and controls
	loadButton.addEventListener('click', () => {
		if (!audioLoaded) return;
		
		// Show player and display area
		audioPlayer.classList.remove('hidden');
		document.getElementById('main-display')!.classList.remove('hidden');
		fileInputsSection.classList.add('collapsed');
		countInControl.classList.remove('hidden');
		countInButtonRow.classList.remove('hidden');
		
		// Create markers if lyrics are loaded
		if (lyrics.length > 0 && audio && audio.duration) {
			createLyricMarkers();
			// Jump to first lyric timestamp
			// Only set currentTime if at the beginning
			if (lyrics[0].time > 0 && Math.abs(audio.currentTime) < 0.01) {
				audio.currentTime = lyrics[0].time;
			}
		}
	});

	// Count-in checkbox handler
	countInEnable.addEventListener('change', () => {
		countInBeatsSelect.disabled = !countInEnable.checked;
	});

	// Count-in beats selection
	countInBeatsSelect.addEventListener('change', () => {
		countInBeats = parseInt(countInBeatsSelect.value);
	});

	// Loop checkbox handler
	loopEnable.addEventListener('change', () => {
		loopEnabled = loopEnable.checked;
		if (loopEnabled) {
			loopTrack.classList.remove('hidden');
			const duration = isUsingTone && tonePlayer ? tonePlayer.buffer.duration : (audio ? audio.duration : 0);
			if (duration) {
				// Initialize loop points - start at first lyric or beginning, end at last lyric or end
				if (lyrics.length > 0) {
					loopStart = lyrics[0].time;
					loopEnd = lyrics[lyrics.length - 1].time || duration;
				} else {
					loopStart = 0;
					loopEnd = duration;
				}
				updateLoopVisuals();
				// Don't jump to loop start - continue playing from current position
				// Loop will trigger when playhead reaches loop end
			}
		} else {
			loopTrack.classList.add('hidden');
		}
	});

	// Loop handle dragging - prevent default drag behavior
	loopStartHandle.addEventListener('dragstart', (e) => e.preventDefault());
	loopEndHandle.addEventListener('dragstart', (e) => e.preventDefault());

	loopStartHandle.addEventListener('mousedown', (e) => {
		console.log('Start handle mousedown');
		isDraggingLoop = true;
		currentDragHandle = 'start';
		// Pause audio while dragging
		if (audio && !audio.paused) {
			audio.pause();
			// Remember to resume after drag
			(loopStartHandle as any).wasPlaying = true;
		}
		e.preventDefault();
		e.stopPropagation();
	});

	loopEndHandle.addEventListener('mousedown', (e) => {
		console.log('End handle mousedown');
		isDraggingLoop = true;
		currentDragHandle = 'end';
		e.preventDefault();
		e.stopPropagation();
	});

	// Touch support for mobile
	loopStartHandle.addEventListener('touchstart', (e) => {
		isDraggingLoop = true;
		currentDragHandle = 'start';
		e.preventDefault();
	});

	loopEndHandle.addEventListener('touchstart', (e) => {
		isDraggingLoop = true;
		currentDragHandle = 'end';
		e.preventDefault();
	});

	document.addEventListener('mousemove', (e) => {
		if (!isDraggingLoop || !audio || !currentDragHandle) return;

		const trackRect = loopTrack.getBoundingClientRect();
		const percent = ((e.clientX - trackRect.left) / trackRect.width) * 100;
		const clampedPercent = Math.max(0, Math.min(100, percent));
		const rawTime = (clampedPercent / 100) * audio.duration;

		if (currentDragHandle === 'start') {
			// Snap to nearest marker
			const snappedTime = findNearestMarker(rawTime);
			// Ensure start is before end
			if (snappedTime < loopEnd) {
				loopStart = snappedTime;
				const snappedPercent = (loopStart / audio.duration) * 100;
				loopStartHandle.style.left = `${snappedPercent}%`;
				// Move playhead along with start marker
				audio.currentTime = loopStart;
			}
		} else if (currentDragHandle === 'end') {
			// Snap to nearest marker
			const snappedTime = findNearestMarker(rawTime);
			// Ensure end is after start
			if (snappedTime > loopStart) {
				loopEnd = snappedTime;
				const snappedPercent = (loopEnd / audio.duration) * 100;
				loopEndHandle.style.left = `${snappedPercent}%`;
			}
		}

		updateLoopArea();
	});

	document.addEventListener('touchmove', (e) => {
		if (!isDraggingLoop || !audio || !currentDragHandle) return;
		
		const touch = e.touches[0];
		const trackRect = loopTrack.getBoundingClientRect();
		const percent = ((touch.clientX - trackRect.left) / trackRect.width) * 100;
		const clampedPercent = Math.max(0, Math.min(100, percent));
		const rawTime = (clampedPercent / 100) * audio.duration;

		if (currentDragHandle === 'start') {
			// Snap to nearest marker
			const snappedTime = findNearestMarker(rawTime);
			// Ensure start is before end
			if (snappedTime < loopEnd) {
				loopStart = snappedTime;
				const snappedPercent = (loopStart / audio.duration) * 100;
				loopStartHandle.style.left = `${snappedPercent}%`;
				// Move playhead along with start marker
				audio.currentTime = loopStart;
			}
		} else if (currentDragHandle === 'end') {
			// Snap to nearest marker
			const snappedTime = findNearestMarker(rawTime);
			// Ensure end is after start
			if (snappedTime > loopStart) {
				loopEnd = snappedTime;
				const snappedPercent = (loopEnd / audio.duration) * 100;
				loopEndHandle.style.left = `${snappedPercent}%`;
			}
		}

		updateLoopArea();
		e.preventDefault();
	});

	document.addEventListener('mouseup', () => {
		if (isDraggingLoop) {
			console.log('Drag ended. Loop:', loopStart, 'to', loopEnd);
			
			// Resume playback if it was playing before drag
			if ((loopStartHandle as any).wasPlaying && audio) {
				audio.play();
				(loopStartHandle as any).wasPlaying = false;
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			}
		}
		isDraggingLoop = false;
		currentDragHandle = null;
	});

	document.addEventListener('touchend', () => {
		isDraggingLoop = false;
		currentDragHandle = null;
	});

	// Find nearest lyric marker to a given time
	function findNearestMarker(time: number): number {
		if (lyrics.length === 0) return time;
		
		let nearest = lyrics[0].time;
		let minDiff = Math.abs(time - nearest);
		
		for (const lyric of lyrics) {
			const diff = Math.abs(time - lyric.time);
			if (diff < minDiff) {
				minDiff = diff;
				nearest = lyric.time;
			}
		}
		
		return nearest;
	}

	function updateLoopVisuals() {
		if (!audio) return;
		const startPercent = (loopStart / audio.duration) * 100;
		const endPercent = (loopEnd / audio.duration) * 100;
		loopStartHandle.style.left = `${startPercent}%`;
		loopEndHandle.style.left = `${endPercent}%`;
		updateLoopArea();
	}

	function updateLoopArea() {
		const startPercent = parseFloat(loopStartHandle.style.left || '10');
		const endPercent = parseFloat(loopEndHandle.style.left || '90');
		loopArea.style.left = `${startPercent}%`;
		loopArea.style.width = `${endPercent - startPercent}%`;
	}

	// Parse LRC format: [mm:ss.xx]Lyric text
	function parseLRC(lrcText: string): Array<{ time: number; text: string }> {
		const lines = lrcText.split('\n');
		const parsed: Array<{ time: number; text: string }> = [];
		
		// Extract metadata if present
		const audioFileMatch = lrcText.match(/\[ti:(.+)\]/);
		if (audioFileMatch && audioFileMatch[1]) {
			const titleInfo = audioFileMatch[1];
			console.log('LRC contains audio file info:', titleInfo);
		}
		
		const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
		
		for (const line of lines) {
			const matches = [...line.matchAll(timeRegex)];
			if (matches.length > 0) {
				const text = line.replace(timeRegex, '').trim();
				// If timestamp exists but no text, use "No Lyrics" as default
				const lyricText = text || 'No Lyrics';
				for (const match of matches) {
					const minutes = parseInt(match[1]);
					const seconds = parseInt(match[2]);
					const centiseconds = parseInt(match[3].padEnd(2, '0').slice(0, 2));
					const time = minutes * 60 + seconds + centiseconds / 100;
					parsed.push({ time, text: lyricText });
				}
			}
		}
		
		return parsed.sort((a, b) => a.time - b.time);
	}

	// Create click sound for count-in
	function createClickSound() {
		const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
		const oscillator = audioContext.createOscillator();
		const gainNode = audioContext.createGain();
		
		oscillator.connect(gainNode);
		gainNode.connect(audioContext.destination);
		
		oscillator.frequency.value = 1000;
		oscillator.type = 'sine';
		
		gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
		gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
		
		oscillator.start(audioContext.currentTime);
		oscillator.stop(audioContext.currentTime + 0.1);
	}

	// BPM-based count-in button handler
	let isCountingIn = false;
	let countInIntervalId: number | null = null;

	countInButton.addEventListener('click', async () => {
		if (!audio || isCountingIn) return;

		// Ensure Tone.js is started
		try {
			if (Tone.context.state !== 'running') {
				await Tone.start();
			}
		} catch (error) {
			console.warn('Audio context start failed:', error);
		}

		// Check if playback is active (don't allow count-in during playback)
		const isPlaying = isUsingTone ? (tonePlayer?.state === 'started') : !audio.paused;
		if (isPlaying) {
			return;
		}

		isCountingIn = true;
		updateCountInButtonState();

		const bpm = parseInt(countInBpmInput.value) || 120;
		const selectedBeats = parseInt(countInBeatsDropdown.value) || 4;
		const beatDurationMs = Math.round(60000 / bpm);
		const ticksPerBeat = Math.max(1, Math.floor(beatDurationMs / 10));

		let currentCount = selectedBeats;
		let tickCounter = 0;

		// Use Tone.js synth for better sound
		let synth: Tone.Synth | null = null;
		try {
			synth = new Tone.Synth({
				oscillator: { type: 'sine' },
				envelope: { attack: 0.002, decay: 0.05, sustain: 0, release: 0.1 },
			}).toDestination();
		} catch (e) {
			console.error('Failed to create Tone.Synth:', e);
			isCountingIn = false;
			updateCountInButtonState();
			return;
		}

		const countdownInterval = setInterval(async () => {
			if (tickCounter % ticksPerBeat === 0 && currentCount > 0) {
				// Display number and play sound
				countInCountdown.textContent = currentCount.toString();
				countInCountdown.classList.remove('hidden');

				// Play click sound
				try {
					synth?.triggerAttackRelease('C4', '0.1');
				} catch (e) {
					console.error('Sound playback error:', e);
				}

				currentCount--;
			}

			tickCounter++;

			// Check if countdown is complete
			if (tickCounter >= selectedBeats * ticksPerBeat) {
				clearInterval(countdownInterval);
				countInCountdown.classList.add('hidden');
				isCountingIn = false;
				updateCountInButtonState();

				// Start playback after count-in
				if (audio) {
					const startTime = isUsingTone ? getCurrentBufferTime() : audio.currentTime;
					if (isUsingTone) {
						playBufferSource(startTime);
					} else {
						audio.play().catch(e => console.error('Play failed:', e));
					}
					playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
					playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
				}
			}
		}, 10);

		countInIntervalId = countdownInterval as any;
	});

	// Update button state based on playback/countdown
	function updateCountInButtonState() {
		const isPlaying = isUsingTone ? (tonePlayer?.state === 'started') : !audio.paused;
		const canClick = !isPlaying && !isCountingIn;

		countInButton.disabled = !canClick;
		countInBpmInput.disabled = !canClick;
		countInBeatsDropdown.disabled = !canClick;
	}

	// Play/Pause control - Enhanced for iOS compatibility
	playPauseBtn.addEventListener('click', async () => {
		if (!audio) return;
		
		// Ensure audio context is started (required for iOS)
		try {
			if (Tone.context.state !== 'running') {
				await Tone.start();
			}
		} catch (error) {
			console.warn('Audio context start failed:', error);
		}
		
		const isPaused = isUsingTone ? (tonePlayer?.state !== 'started') : audio.paused;
		
		if (isPaused) {
			// Check if count-in is enabled and we're at/before the first lyric
			const currentTime = isUsingTone ? getCurrentBufferTime() : audio.currentTime;
			const isAtStart = lyrics.length > 0 ? currentTime <= lyrics[0].time : currentTime === 0;
			
			if (countInEnable.checked && isAtStart && lyrics.length > 0) {
				const beatsCount = parseInt(countInBeatsSelect.value);
				
				// Display count-in beats with click sound
				for (let i = 1; i <= beatsCount; i++) {
					createClickSound();
					currentLyricDisplay.textContent = `${i}`;
					currentLyricDisplay.style.fontSize = 'clamp(3rem, 10vw, 5rem)';
					currentLyricDisplay.style.color = 'var(--accent-regular)';
					
					// Wait 1 second before next beat
					await new Promise(resolve => setTimeout(resolve, 1000));
				}
				
				// Reset font size and start playback
				currentLyricDisplay.style.fontSize = '';
				currentLyricDisplay.style.color = '';
				currentLyricDisplay.textContent = '';
				
				// Start from current playhead position, not from first lyric
				let startTime = currentTime;
				// If loop is enabled and current position is outside loop boundaries, start from loop start
				if (loopEnabled && loopEnd > 0 && (startTime < loopStart || startTime >= loopEnd)) {
					startTime = loopStart;
					console.log(`[Count-in] Loop enabled, adjusting start position from ${currentTime.toFixed(2)}s to loop start ${loopStart.toFixed(2)}s`);
				}
				if (isUsingTone) {
					playBufferSource(startTime);
				} else {
					audio.currentTime = startTime;
					audio.play().catch(e => {
						console.error('Play failed:', e);
						// Reset button state on error
						playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
						playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
					});
				}
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			} else {
				if (isUsingTone) {
					let resumeTime = getCurrentBufferTime();
					console.log(`[Resume] Current buffer time: ${resumeTime.toFixed(2)}s, loop enabled: ${loopEnabled}, loopStart: ${loopStart.toFixed(2)}s, loopEnd: ${loopEnd.toFixed(2)}s`);
					// If loop is enabled and current position is outside loop boundaries, start from loop start
					if (loopEnabled && loopEnd > 0) {
						if (resumeTime < loopStart || resumeTime >= loopEnd) {
							console.log(`[Resume] Position ${resumeTime.toFixed(2)}s is outside loop [${loopStart.toFixed(2)}s, ${loopEnd.toFixed(2)}s], adjusting to loop start`);
							resumeTime = loopStart;
						} else {
							console.log(`[Resume] Position ${resumeTime.toFixed(2)}s is within loop boundaries, resuming from there`);
						}
					}
					playBufferSource(resumeTime);
				} else {
					audio.play().then(() => {
						console.log('HTML5 audio play started successfully');
					}).catch(e => {
						console.error('HTML5 audio play failed:', e);
						// Reset button state on error
						playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
						playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
					});
				}
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			}
		} else {
			if (isUsingTone) {
				// Update lastSeekTime to current position before stopping
				lastSeekTime = getCurrentBufferTime();
				stopBufferSource();
			} else {
				audio.pause();
			}
			playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
			playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
		}
		updateCountInButtonState();
	});

	// Stop control
	stopBtn.addEventListener('click', () => {
		if (!audio) return;
		
		// Find first marker or go to start
		const sortedMarkers = lyrics
			.map(l => l.time)
			.sort((a, b) => a - b);
		const firstMarkerTime = sortedMarkers.length > 0 ? sortedMarkers[0] : 0;
		
		if (isUsingTone && tonePlayer) {
			stopBufferSource();
			tonePlayer.seek(firstMarkerTime);
			lastSeekTime = firstMarkerTime;
			playbackStartTime = Tone.now();
		} else {
			audio.pause();
			audio.currentTime = firstMarkerTime;
		}
		
		playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
		playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
		currentLyricIndex = -1;
		displayUpcomingLyrics();
	});

	// Seek control - Enhanced for iOS touch support
	seekBar.addEventListener('input', handleSeek);
	seekBar.addEventListener('change', handleSeek); // iOS fires change instead of input during touch
	
	// Add touch event listeners for better iOS support
	seekBar.addEventListener('touchstart', (e) => {
		// Prevent default to avoid scrolling on iOS
		e.preventDefault();
	});
	
	seekBar.addEventListener('touchmove', (e) => {
		// Handle continuous touch dragging on iOS
		e.preventDefault();
		const touch = e.touches[0];
		const rect = seekBar.getBoundingClientRect();
		const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
		const newTime = percent * parseFloat(seekBar.max);
		seekBar.value = newTime.toString();
		handleSeek();
	});
	
	seekBar.addEventListener('touchend', (e) => {
		e.preventDefault();
		handleSeek();
	});
	
	function handleSeek() {
		if (!audio) return;
		const newTime = parseFloat(seekBar.value);
		console.log('[SeekBar] Playhead moved to:', newTime.toFixed(2), 's, loop enabled:', loopEnabled, 'loop bounds:', loopStart.toFixed(2), '-', loopEnd.toFixed(2));
		const isWithinLoop = loopEnabled && loopEnd > 0 && newTime >= loopStart && newTime < loopEnd;
		console.log('[SeekBar] Position within loop:', isWithinLoop);

		if (isUsingTone && tonePlayer) {
			const wasPlaying = tonePlayer.state === 'started';
			console.log('[SeekBar] Tone.js wasPlaying:', wasPlaying);

			if (wasPlaying) {
				console.log('[SeekBar] Seeking Tone.js to', newTime, 'without stopping playback');
				tonePlayer.seek(newTime);
				lastSeekTime = newTime;
				playbackStartTime = Tone.now();
				// Update UI immediately when seeking during playback
				currentTimeDisplay.textContent = formatTime(newTime);
				const duration = tonePlayer.buffer.duration;
				const progress = (newTime / duration) * 100;
				progressFill.style.width = `${progress}%`;
				updateLyrics(newTime);
				updateNotation(newTime);
				updateMarkers(newTime);
			} else {
				console.log('[SeekBar] Seeking Tone.js to', newTime, 'while paused');
				tonePlayer.seek(newTime);
				lastSeekTime = newTime;
				playbackStartTime = Tone.now();
				// Update UI when seeking while paused
				currentTimeDisplay.textContent = formatTime(newTime);
				const duration = tonePlayer.buffer.duration;
				const progress = (newTime / duration) * 100;
				progressFill.style.width = `${progress}%`;
				updateLyrics(newTime);
				updateNotation(newTime);
				updateMarkers(newTime);
			}
			if (loopEnabled) {
				updateLoopVisuals();
				console.log('[SeekBar] Loop state after seek:', { loopStart, loopEnd });
			}
		} else {
			const wasPlaying = !audio.paused;
			console.log('[SeekBar] HTML5 audio wasPlaying:', wasPlaying);

			audio.currentTime = newTime;
			currentTimeDisplay.textContent = formatTime(newTime);
			const progress = (newTime / audio.duration) * 100;
			progressFill.style.width = `${progress}%`;
			updateLyrics(newTime);
			updateNotation(newTime);
			updateMarkers(newTime);

			// Only restart playback if it was playing before (and loop is disabled)
			if (wasPlaying && !loopEnabled) {
				console.log('[SeekBar] Continuing HTML5 audio playback from', newTime);
				// Don't call play() here - just let it continue from the new position
			}
			if (loopEnabled) {
				updateLoopVisuals();
				console.log('[SeekBar] Loop state after seek:', { loopStart, loopEnd });
			}
		}
	}

	// Volume control
	volumeControl.addEventListener('input', () => {
		const volume = parseInt(volumeControl.value) / 100;
		
		if (toneGain) {
			toneGain.gain.value = volume;
		}
		if (audio) {
			audio.volume = volume;
		}
	});

	// Update progress and lyrics
	function updateProgress() {
		if (!audio) return;
		
		const currentTime = audio.currentTime;
		currentTimeDisplay.textContent = formatTime(currentTime);
		seekBar.value = currentTime.toString();
		const progress = (currentTime / audio.duration) * 100;
		progressFill.style.width = `${progress}%`;

		// Update playhead indicator position
		const playheadIndicator = document.querySelector('.playhead-indicator') as HTMLElement;
		if (playheadIndicator) {
			playheadIndicator.style.left = `calc(${progress}% - 8px)`;
		}

		// Handle loop
		if (loopEnabled && currentTime >= loopEnd) {
			audio.currentTime = loopStart;
		}

		// Update lyrics and notation
		updateLyrics(currentTime);
		updateNotation(currentTime);
		updateMarkers(currentTime);
	}

	function updateLyrics(currentTime: number) {
		if (lyrics.length === 0) return;

		// Find current lyric
		let newIndex = -1;
		for (let i = 0; i < lyrics.length; i++) {
			if (lyrics[i].time <= currentTime) {
				newIndex = i;
			} else {
				break;
			}
		}

		if (newIndex !== currentLyricIndex) {
			currentLyricIndex = newIndex;
			
			if (currentLyricIndex >= 0) {
				currentLyricDisplay.textContent = lyrics[currentLyricIndex].text;
			} else {
				currentLyricDisplay.textContent = '';
			}
			
			displayUpcomingLyrics();
		}
	}

	function updateNotation(currentTime: number) {
		if (notation.length === 0) return;

		// Find current notation
		let newIndex = -1;
		for (let i = 0; i < notation.length; i++) {
			if (notation[i].time <= currentTime) {
				newIndex = i;
			} else {
				break;
			}
		}

		if (newIndex !== currentNotationIndex) {
			currentNotationIndex = newIndex;
			
			if (currentNotationIndex >= 0) {
				currentNotationDisplay.textContent = notation[currentNotationIndex].text;
			} else {
				currentNotationDisplay.textContent = '';
			}
		}
	}

	function displayUpcomingLyrics() {
		const startIndex = Math.max(0, currentLyricIndex + 1);
		const endIndex = Math.min(lyrics.length, startIndex + 2); // Show only 2 lines
		const upcoming = lyrics.slice(startIndex, endIndex);
		
		upcomingLyricsDisplay.innerHTML = upcoming
			.map(lyric => `<span class="lyric-line">${lyric.text}</span>`)
			.join('');
	}

	function updateSongMetadata() {
		const songMetadata = document.getElementById('song-metadata') as HTMLElement;
		const songTitleEl = document.getElementById('song-title') as HTMLElement;
		const arohanamText = document.getElementById('arohanam-text') as HTMLElement;
		const avarohanamText = document.getElementById('avarohanam-text') as HTMLElement;
		
		if (songTitle) {
			songTitleEl.textContent = songTitle;
			songMetadata.classList.remove('hidden');
		}
		
		if (aarohanam) {
			arohanamText.textContent = aarohanam;
		}
		
		if (avarohanam) {
			avarohanamText.textContent = avarohanam;
		}
	}

	// Create visual markers for lyric timestamps
	function createLyricMarkers() {
		if (!audio || lyrics.length === 0) {
			console.log('Cannot create markers:', { audio: !!audio, lyricsCount: lyrics.length });
			return;
		}
		
		const markersContainer = document.getElementById('lyric-markers');
		if (!markersContainer) {
			console.log('Markers container not found');
			return;
		}
		
		markersContainer.innerHTML = '';
		const duration = audio.duration;
		
		console.log('Creating markers for', lyrics.length, 'lyrics, duration:', duration);
		
		lyrics.forEach((lyric, index) => {
			const marker = document.createElement('div');
			marker.className = 'lyric-marker';
			marker.dataset.index = index.toString();
			const position = (lyric.time / duration) * 100;
			marker.style.left = `${position}%`;
			marker.style.transform = 'translateX(-50%)';
			marker.style.backgroundColor = '#888'; // Force background color
			marker.style.width = '3px'; // Force width
			marker.style.height = '100%'; // Force height
			marker.style.position = 'absolute'; // Force position
			marker.style.top = '0'; // Force top
			markersContainer.appendChild(marker);
			console.log(`Marker ${index}: ${lyric.time}s at ${position}%`, marker);
		});
		
		console.log('Markers created:', markersContainer.children.length);
		console.log('Markers container:', markersContainer, 'Computed style:', window.getComputedStyle(markersContainer));
	}

	// Update active marker
	function updateMarkers(currentTime: number) {
		const markers = document.querySelectorAll('.lyric-marker');
		markers.forEach((marker) => {
			const index = parseInt((marker as HTMLElement).dataset.index || '-1');
			if (index === currentLyricIndex) {
				marker.classList.add('active');
			} else {
				marker.classList.remove('active');
			}
		});
	}

	// Detect iOS and force HTML5 audio fallback
	const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
	              (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
	const isIOSChrome = isIOS && /CriOS/.test(navigator.userAgent);
	
	if (isIOS || isIOSChrome) {
		console.log('iOS detected - forcing HTML5 audio fallback for better compatibility');
		isUsingTone = false;
	}

	// Initialize audio processing (not needed for basic playbackRate control)
	async function initializeAudioProcessing() {
		if (!audio) return;
		
		// Skip Tone.js initialization on iOS
		if (isIOS || isIOSChrome) {
			console.log('Skipping Tone.js initialization on iOS - using HTML5 audio fallback');
			audio.playbackRate = playbackSpeed;
			audio.preservesPitch = true;
			isUsingTone = false;
			return;
		}
		
		try {
			// Start Tone.js audio context
			await Tone.start();
			
			// Create Tone.js Player
			tonePlayer = new Tone.Player({
				url: audio.src,
				loop: false,
				autostart: false
			}).toDestination();
			
			// Wait for player to load
			await Tone.loaded();
			
			// Create pitch shifter (independent of speed)
			pitchShifter = new Tone.PitchShift(pitchShift);
			
			// Create gain node
			toneGain = new Tone.Gain(parseInt(volumeControl.value) / 100);
			
			// Connect: Player -> PitchShift -> Gain -> Destination
			tonePlayer.disconnect();
			tonePlayer.chain(pitchShifter, toneGain, Tone.Destination);
			
			// Set initial playback rate for speed
			tonePlayer.playbackRate = playbackSpeed;
			
			isUsingTone = true;
			console.log('Tone.js initialized - independent pitch/speed control enabled');
			
		} catch (error) {
			console.error('Tone.js initialization failed:', error);
			isUsingTone = false;
			// Fallback to HTML5 audio
			audio.playbackRate = playbackSpeed;
			audio.preservesPitch = true;
		}
	}

	// Pitch control handlers
	pitchDownBtn.addEventListener('click', () => {
		if (pitchShift > -12) {
			pitchShift -= 0.5;
			updatePitchDisplay();
			applyPitchShift();
		}
	});

	pitchUpBtn.addEventListener('click', () => {
		if (pitchShift < 12) {
			pitchShift += 0.5;
			updatePitchDisplay();
			applyPitchShift();
		}
	});

	pitchResetBtn.addEventListener('click', () => {
		pitchShift = 0;
		updatePitchDisplay();
		applyPitchShift();
	});

	function updatePitchDisplay() {
		const sign = pitchShift > 0 ? '+' : '';
		pitchDisplay.textContent = `${sign}${pitchShift.toFixed(1)}`;
	}

	function applyPitchShift() {
		if (!audio) return;
		
		if (isUsingTone && pitchShifter && tonePlayer) {
			// Compensate for pitch change caused by playbackRate
			const playbackPitchShift = 12 * Math.log2(playbackSpeed);
			const compensatedPitch = pitchShift - playbackPitchShift;
			pitchShifter.pitch = compensatedPitch;
			console.log(`Pitch: ${pitchShift} semitones (compensated: ${compensatedPitch.toFixed(2)} for speed ${playbackSpeed}x)`);
		} else {
			// Fallback to HTML5 audio (pitch affects speed)
			if (pitchShift === 0) {
				audio.preservesPitch = true;
				audio.playbackRate = playbackSpeed;
			} else {
				const pitchRatio = Math.pow(2, pitchShift / 12);
				audio.preservesPitch = false;
				audio.playbackRate = pitchRatio;
				console.log(`Pitch: ${pitchShift} semitones (fallback - affects tempo)`);
			}
		}
	}

	// Speed control handlers
	speedDownBtn.addEventListener('click', () => {
		if (playbackSpeed > 0.25) {
			playbackSpeed = Math.max(0.25, playbackSpeed - 0.1);
			updateSpeedDisplay();
			applySpeed();
		}
	});

	speedUpBtn.addEventListener('click', () => {
		if (playbackSpeed < 2.0) {
			playbackSpeed = Math.min(2.0, playbackSpeed + 0.1);
			updateSpeedDisplay();
			applySpeed();
		}
	});

	speedResetBtn.addEventListener('click', () => {
		playbackSpeed = 1.0;
		updateSpeedDisplay();
		applySpeed();
	});

	function updateSpeedDisplay() {
		speedDisplay.textContent = `${playbackSpeed.toFixed(1)}x`;
	}

	function applySpeed() {
		if (!audio) return;
		
		if (isUsingTone && tonePlayer && pitchShifter) {
			// Tone.js: playbackRate affects pitch, so compensate
			// Set playbackRate for speed
			tonePlayer.playbackRate = playbackSpeed;
			// Calculate pitch shift needed to compensate for playbackRate pitch change
			// playbackRate changes pitch by: 12 * log2(playbackRate) semitones
			const playbackPitchShift = 12 * Math.log2(playbackSpeed);
			// Compensate by shifting pitch in opposite direction, then add user's desired pitch
			const compensatedPitch = pitchShift - playbackPitchShift;
			pitchShifter.pitch = compensatedPitch;
			console.log(`Speed: ${playbackSpeed}x, Pitch: ${pitchShift} semitones (compensated: ${compensatedPitch.toFixed(2)})`);
		} else {
			// Fallback to HTML5 audio
			if (pitchShift === 0) {
				audio.preservesPitch = true;
				audio.playbackRate = playbackSpeed;
				console.log(`Speed: ${playbackSpeed}x (pitch preserved)`);
			} else {
				console.log(`Speed control limited when pitch active (fallback mode)`);
			}
		}
	}

	// Tone.js playback functions
	function playBufferSource(offset: number = 0) {
		if (!tonePlayer || !isUsingTone) return;
		
		try {
			// Stop immediately (with 0 fade time) if already playing
			if (tonePlayer.state === 'started') {
				tonePlayer.stop(0);
			}
			
			// Cancel any pending sync loops
			cancelAnimationFrame(rafId);
			
			// Start playback first, then seek to offset
			tonePlayer.start();
			// Small delay to ensure playback has started before seeking
			setTimeout(() => {
				if (tonePlayer) {
					tonePlayer.seek(offset);
					lastSeekTime = offset;
					playbackStartTime = Tone.now();
					console.log(`Tone.js seeked to ${offset}s after starting playback`);
				}
			}, 10);
			
			// Start UI sync loop
			rafId = requestAnimationFrame(syncBufferToUI);
			
			console.log(`Tone.js playback started (will seek to ${offset}s) with speed ${playbackSpeed}x and pitch ${pitchShift} semitones (independent)`);
		} catch (e) {
			console.error('Play error:', e);
		}
	}

	function stopBufferSource() {
		if (!tonePlayer || !isUsingTone) return;
		
		try {
			if (tonePlayer.state === 'started') {
				tonePlayer.stop(0); // Stop immediately with 0 fade
			}
			cancelAnimationFrame(rafId);
		} catch (e) {
			console.error('Stop error:', e);
		}
	}

	function getCurrentBufferTime(): number {
		if (!tonePlayer || !isUsingTone) return 0;
		
		// Calculate actual playback time based on seek position and elapsed time
		if (tonePlayer.state === 'started') {
			const elapsedTime = (Tone.now() - playbackStartTime) * playbackSpeed;
			return lastSeekTime + elapsedTime;
		}
		return lastSeekTime;
	}

	// Sync Tone.js playback to UI
	function syncBufferToUI() {
		if (!isUsingTone || !tonePlayer) return;
		
		const currentTime = getCurrentBufferTime();
		const duration = tonePlayer.buffer.duration;
		
		// Update UI elements
		currentTimeDisplay.textContent = formatTime(currentTime);
		seekBar.value = currentTime.toString();
		
		const progress = (currentTime / duration) * 100;
		progressFill.style.width = `${progress}%`;
		
		// Update playhead indicator
		const playheadIndicator = document.querySelector('.playhead-indicator') as HTMLElement;
		if (playheadIndicator) {
			playheadIndicator.style.left = `calc(${progress}% - 8px)`;
		}
		
		// Handle loop
		if (loopEnabled && loopEnd > 0 && currentTime >= loopEnd) {
			console.log(`Looping: ${currentTime.toFixed(2)}s >= ${loopEnd.toFixed(2)}s, jumping to ${loopStart.toFixed(2)}s`);
			// Just seek to loop start - player continues
			tonePlayer.seek(loopStart);
			lastSeekTime = loopStart;
			playbackStartTime = Tone.now();
		}
		
		// Update lyrics and notation
		updateLyrics(currentTime);
		updateNotation(currentTime);
		updateMarkers(currentTime);
		
		// Continue syncing if playing
		if (tonePlayer.state === 'started') {
			rafId = requestAnimationFrame(syncBufferToUI);
		}
	}

	function formatTime(seconds: number): string {
		const mins = Math.floor(seconds / 60);
		const secs = Math.floor(seconds % 60);
		return `${mins}:${secs.toString().padStart(2, '0')}`;
	}
</script>
