---
import BaseLayout from '../layouts/BaseLayout.astro';
---

<BaseLayout
	title="Rehearsal Studio | Mandolin Balaji"
	description="Practice with synchronized lyrics"
>
	<div class="rehearsal-container">
		<header>
			<h1 class="hero-title">Rehearsal Studio</h1>
			<p class="hero-tagline">Practice with time-synced lyrics</p>
		</header>

			<div class="controls-section">
				<div id="file-inputs" class="file-inputs">
					<div class="input-group">
						<label for="audio-file">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M9 18V5l12-2v13"></path>
								<circle cx="6" cy="18" r="3"></circle>
								<circle cx="18" cy="16" r="3"></circle>
							</svg>
							Load Audio (MP3)
						</label>
						<input type="file" id="audio-file" accept="audio/mp3,audio/mpeg" />
					</div>

					<div class="input-group">
						<label for="lyrics-file">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
								<polyline points="14 2 14 8 20 8"></polyline>
								<line x1="16" y1="13" x2="8" y2="13"></line>
								<line x1="16" y1="17" x2="8" y2="17"></line>
								<polyline points="10 9 9 9 8 9"></polyline>
							</svg>
							Load Lyrics (LRC)
						</label>
						<input type="file" id="lyrics-file" accept=".lrc,text/plain" />
					</div>
				</div>

				<div id="count-in-control" class="count-in-control hidden">
					<label class="checkbox-label">
						<input type="checkbox" id="count-in-enable" />
						<span>Count-in:</span>
					</label>
					<select id="count-in-beats" disabled>
						<option value="1">1</option>
						<option value="2">2</option>
						<option value="3">3</option>
						<option value="4" selected>4</option>
					</select>
					<label class="checkbox-label loop-label">
						<input type="checkbox" id="loop-enable" />
						<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
							<path d="M17 1l4 4-4 4"/>
							<path d="M3 11V9a4 4 0 0 1 4-4h14"/>
							<path d="M7 23l-4-4 4-4"/>
							<path d="M21 13v2a4 4 0 0 1-4 4H3"/>
						</svg>
					</label>
				</div>

				<div id="audio-player" class="audio-player hidden">
					<div class="waveform-container">
						<div class="playhead-indicator">
							<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
								<path d="M7 10l5 5 5-5z"/>
							</svg>
						</div>
						<div class="time-display">
							<span id="current-time">0:00</span>
							<span id="duration">0:00</span>
						</div>
						<div class="progress-wrapper">
							<div class="progress-bar">
								<div id="progress-fill" class="progress-fill"></div>
								<input type="range" id="seek-bar" min="0" max="100" value="0" step="0.1" />
							</div>
							<div class="markers-track">
								<div id="lyric-markers" class="lyric-markers"></div>
							</div>
							<div id="loop-track" class="loop-track hidden">
								<div id="loop-region" class="loop-region">
									<div id="loop-start-handle" class="loop-handle loop-start">
										<div class="loop-line"></div>
										<div class="loop-grip">⋮</div>
									</div>
									<div class="loop-area"></div>
									<div id="loop-end-handle" class="loop-handle loop-end">
										<div class="loop-line"></div>
										<div class="loop-grip">⋮</div>
									</div>
								</div>
							</div>
						</div>
					</div>

					<div class="player-controls">
						<button id="play-pause" class="control-btn primary">
							<svg class="play-icon" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
								<path d="M8 5v14l11-7z"/>
							</svg>
							<svg class="pause-icon hidden" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
								<path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
							</svg>
						</button>
						<button id="stop" class="control-btn">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
								<rect x="6" y="6" width="12" height="12"/>
							</svg>
						</button>
						<div class="volume-control">
							<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
								<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
								<path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
								<path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
							</svg>
							<input type="range" id="volume" min="0" max="100" value="80" />
						</div>
					</div>
				</div>
			</div>

		<div id="lyrics-display" class="lyrics-display hidden">
			<div class="lyric-container">
				<div class="lyric-indicator">
					<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
						<path d="M8 5v14l11-7z"/>
					</svg>
				</div>
				<div class="lyric-content">
					<div id="current-lyric" class="current-lyric">
						<!-- Current lyric will appear here -->
					</div>
					<div id="upcoming-lyrics" class="upcoming-lyrics">
						<!-- Upcoming lyrics will appear here -->
					</div>
				</div>
			</div>
		</div>
	</div>
</BaseLayout>

<style>
	.rehearsal-container {
		padding: 1rem;
		max-width: 900px;
		margin: 0 auto;
	}

	.hero-title {
		font-size: var(--text-3xl);
		color: var(--gray-0);
		line-height: 1.1;
		margin-bottom: 0.5rem;
	}

	@media (max-width: 768px) {
		.hero-title {
			font-size: var(--text-xl);
			margin-bottom: 0.25rem;
		}
		
		.hero-tagline {
			font-size: var(--text-base);
		}
	}

	.hero-tagline {
		color: var(--gray-300);
		font-size: var(--text-lg);
		margin-bottom: 0.5rem;
	}
	
	header {
		margin-bottom: 1rem;
	}

	.controls-section {
		background: var(--gray-999);
		border: 1px solid var(--gray-800);
		border-radius: 1rem;
		padding: 1.5rem;
	}

	.file-inputs {
		display: flex;
		flex-direction: column;
		gap: 1rem;
		margin-bottom: 1.5rem;
		transition: all 0.3s ease;
	}

	.file-inputs.collapsed {
		max-height: 0;
		overflow: hidden;
		margin-bottom: 0;
		opacity: 0;
	}

	.count-in-control {
		display: flex;
		align-items: center;
		gap: 0.75rem;
		margin-bottom: 1rem;
		padding: 0.5rem 0.75rem;
		background: var(--gray-900);
		border-radius: 0.5rem;
		flex-wrap: nowrap;
	}
	
	.loop-label {
		margin-left: auto;
	}
	
	.loop-label svg {
		color: var(--accent-regular);
	}

	.checkbox-label {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		cursor: pointer;
		color: var(--gray-200);
		font-size: var(--text-sm);
		user-select: none;
		white-space: nowrap;
	}

	.checkbox-label input[type="checkbox"] {
		width: 18px;
		height: 18px;
		cursor: pointer;
		accent-color: var(--accent-regular);
	}

	#count-in-beats {
		padding: 0.25rem 0.5rem;
		background: var(--gray-800);
		border: 1px solid var(--gray-700);
		border-radius: 0.375rem;
		color: var(--gray-200);
		font-size: var(--text-sm);
		cursor: pointer;
		min-width: 50px;
	}

	#count-in-beats:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.input-group {
		display: flex;
		flex-direction: column;
		gap: 0.5rem;
	}

	.input-group label {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		font-weight: 600;
		color: var(--gray-200);
		cursor: pointer;
		font-size: var(--text-sm);
	}

	.input-group input[type="file"] {
		padding: 0.75rem;
		background: var(--gray-900);
		border: 2px dashed var(--gray-700);
		border-radius: 0.5rem;
		color: var(--gray-200);
		cursor: pointer;
		font-size: var(--text-sm);
	}

	.input-group input[type="file"]:hover {
		border-color: var(--accent-regular);
	}

	.audio-player {
		margin-top: 1rem;
		padding-top: 1.5rem;
		border-top: 1px solid var(--gray-800);
	}

	.waveform-container {
		margin-bottom: 1rem;
		position: relative;
	}

	.playhead-indicator {
		position: absolute;
		top: -20px;
		left: 0;
		color: var(--accent-regular);
		transition: left 0.1s linear;
		z-index: 10;
		filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
	}

	.time-display {
		display: flex;
		justify-content: space-between;
		margin-bottom: 0.5rem;
		font-size: var(--text-sm);
		color: var(--gray-300);
		font-variant-numeric: tabular-nums;
	}

	.progress-wrapper {
		display: flex;
		flex-direction: column;
		gap: 0;
	}

	.progress-bar {
		position: relative;
		height: 8px;
		background: var(--gray-800);
		border-radius: 4px;
		overflow: hidden;
	}

	@media (max-width: 768px) {
		.progress-bar {
			height: 12px;
		}
	}

	.markers-track {
		position: relative;
		height: 20px;
		background: #1a1a1a;
		border: 1px solid var(--gray-800);
		border-top: none;
	}

	.loop-track {
		position: relative;
		height: 30px;
		background: #0a0a0a;
		border: 1px solid var(--gray-800);
		border-top: none;
		border-radius: 0 0 4px 4px;
	}

	.loop-region {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.loop-handle {
		position: absolute;
		top: 0;
		width: 20px;
		height: 100%;
		cursor: ew-resize;
		z-index: 20;
		display: flex;
		align-items: center;
		justify-content: center;
		transform: translateX(-50%);
	}

	.loop-handle:hover {
		opacity: 0.8;
	}

	.loop-handle:active {
		opacity: 1;
	}

	.loop-start {
		left: 10%;
	}

	.loop-end {
		left: 90%;
	}

	.loop-line {
		position: absolute;
		top: 0;
		left: 50%;
		transform: translateX(-50%);
		width: 3px;
		height: 100%;
		background: var(--accent-regular);
		box-shadow: 0 0 8px var(--accent-regular);
	}

	.loop-grip {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		font-size: 1.2rem;
		color: var(--accent-regular);
		text-shadow: 0 0 4px var(--accent-regular);
		user-select: none;
	}

	.loop-area {
		position: absolute;
		top: 0;
		height: 100%;
		background: var(--accent-regular);
		opacity: 0.2;
		pointer-events: none;
	}

	.lyric-markers {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
	}

	.lyric-marker {
		position: absolute;
		top: 0;
		width: 3px;
		height: 100%;
		background: #888;
		transform: translateX(-50%);
		transition: all 0.2s;
		border-radius: 1px;
	}

	.lyric-marker.active {
		background: var(--accent-regular);
		width: 4px;
		box-shadow: 0 0 8px var(--accent-regular);
		z-index: 5;
	}

	.progress-fill {
		position: absolute;
		height: 100%;
		background: var(--accent-regular);
		border-radius: 4px;
		width: 0%;
		transition: width 0.1s linear;
	}

	#seek-bar {
		position: absolute;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		opacity: 0;
		cursor: pointer;
		z-index: 15;
	}

	#seek-bar::-webkit-slider-thumb {
		width: 16px;
		height: 16px;
		cursor: pointer;
	}

	@media (max-width: 768px) {
		#seek-bar::-webkit-slider-thumb {
			width: 44px;
			height: 44px;
		}
	}

	.player-controls {
		display: flex;
		align-items: center;
		gap: 1rem;
		flex-wrap: wrap;
	}

	.control-btn {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 48px;
		height: 48px;
		border: none;
		border-radius: 50%;
		background: var(--gray-800);
		color: var(--gray-0);
		cursor: pointer;
		transition: all 0.2s;
	}

	.control-btn:hover {
		background: var(--gray-700);
		transform: scale(1.05);
	}

	.control-btn.primary {
		background: var(--accent-regular);
		width: 56px;
		height: 56px;
	}

	.control-btn.primary:hover {
		background: var(--accent-dark);
	}

	.volume-control {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		margin-left: auto;
		color: var(--gray-300);
	}

	.volume-control input[type="range"] {
		width: 100px;
	}

	input[type="range"] {
		-webkit-appearance: none;
		appearance: none;
		background: var(--gray-800);
		border-radius: 4px;
		height: 6px;
		outline: none;
	}

	input[type="range"]::-webkit-slider-thumb {
		-webkit-appearance: none;
		appearance: none;
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background: var(--accent-regular);
		cursor: pointer;
	}

	input[type="range"]::-moz-range-thumb {
		width: 16px;
		height: 16px;
		border-radius: 50%;
		background: var(--accent-regular);
		cursor: pointer;
		border: none;
	}

	.lyrics-display {
		background: var(--gradient-subtle);
		border: 1px solid var(--gray-800);
		border-radius: 1rem;
		padding: 2rem;
		min-height: 300px;
		display: flex;
		flex-direction: column;
		justify-content: center;
		align-items: center;
	}

	@media (max-width: 768px) {
		.lyrics-display {
			padding: 1rem;
			min-height: 200px;
			max-height: 40vh;
			overflow-y: auto;
		}
	}

	.lyric-container {
		display: flex;
		align-items: flex-start;
		gap: 1rem;
		width: 100%;
		max-width: 700px;
	}

	.lyric-indicator {
		flex-shrink: 0;
		color: var(--accent-regular);
		margin-top: 0.5rem;
		animation: pulse 1.5s ease-in-out infinite;
	}

	.lyric-content {
		flex: 1;
		text-align: left;
	}

	.current-lyric {
		font-size: clamp(1.5rem, 5vw, 2.5rem);
		font-weight: 700;
		color: var(--accent-regular);
		line-height: 1.4;
		margin-bottom: 2rem;
		min-height: 3rem;
		animation: fadeIn 0.3s ease-in-out;
	}

	@keyframes pulse {
		0%, 100% {
			opacity: 1;
			transform: translateX(0);
		}
		50% {
			opacity: 0.6;
			transform: translateX(3px);
		}
	}

	.upcoming-lyrics {
		font-size: clamp(1rem, 3vw, 1.25rem);
		color: var(--gray-400);
		line-height: 1.8;
		max-width: 600px;
	}

	.upcoming-lyrics .lyric-line {
		display: block;
		margin: 0.5rem 0;
		opacity: 0.7;
		transition: opacity 0.3s;
	}

	.hidden {
		display: none !important;
	}

	@keyframes fadeIn {
		from {
			opacity: 0;
			transform: translateY(-10px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}

	@media (max-width: 768px) {
		.rehearsal-container {
			padding: 0.5rem;
		}

		.controls-section {
			padding: 0.75rem;
		}

		.player-controls {
			justify-content: center;
		}

		.control-btn {
			width: 44px;
			height: 44px;
		}

		.control-btn.primary {
			width: 52px;
			height: 52px;
		}

		.volume-control {
			margin-left: 0;
			width: 100%;
			justify-content: center;
		}

		.volume-control input[type="range"] {
			flex: 1;
			max-width: 200px;
		}

		.lyric-container {
			flex-direction: column;
			align-items: center;
		}

		.lyric-indicator {
			transform: rotate(90deg);
			margin-top: 0;
			margin-bottom: 0.5rem;
		}

		.lyric-content {
			text-align: center;
		}

		.current-lyric {
			margin-bottom: 1rem;
			min-height: 2rem;
		}

		.count-in-control {
			gap: 0.5rem;
		}

		.loop-handle {
			width: 44px;
		}
	}
</style>

<script>
	let audio: HTMLAudioElement | null = null;
	let lyrics: Array<{ time: number; text: string }> = [];
	let currentLyricIndex = -1;
	let countInBeats = 0;
	let audioLoaded = false;
	let lyricsLoaded = false;
	let loopEnabled = false;
	let loopStart = 0;
	let loopEnd = 0;
	let isDraggingLoop = false;
	let currentDragHandle: 'start' | 'end' | null = null;

	const audioFileInput = document.getElementById('audio-file') as HTMLInputElement;
	const lyricsFileInput = document.getElementById('lyrics-file') as HTMLInputElement;
	const fileInputsSection = document.getElementById('file-inputs') as HTMLDivElement;
	const audioPlayer = document.getElementById('audio-player') as HTMLDivElement;
	const lyricsDisplay = document.getElementById('lyrics-display') as HTMLDivElement;
	const playPauseBtn = document.getElementById('play-pause') as HTMLButtonElement;
	const stopBtn = document.getElementById('stop') as HTMLButtonElement;
	const seekBar = document.getElementById('seek-bar') as HTMLInputElement;
	const volumeControl = document.getElementById('volume') as HTMLInputElement;
	const currentTimeDisplay = document.getElementById('current-time') as HTMLSpanElement;
	const durationDisplay = document.getElementById('duration') as HTMLSpanElement;
	const progressFill = document.getElementById('progress-fill') as HTMLDivElement;
	const currentLyricDisplay = document.getElementById('current-lyric') as HTMLDivElement;
	const upcomingLyricsDisplay = document.getElementById('upcoming-lyrics') as HTMLDivElement;
	const countInControl = document.getElementById('count-in-control') as HTMLDivElement;
	const countInEnable = document.getElementById('count-in-enable') as HTMLInputElement;
	const countInBeatsSelect = document.getElementById('count-in-beats') as HTMLSelectElement;
	const loopEnable = document.getElementById('loop-enable') as HTMLInputElement;
	const loopTrack = document.getElementById('loop-track') as HTMLDivElement;
	const loopStartHandle = document.getElementById('loop-start-handle') as HTMLDivElement;
	const loopEndHandle = document.getElementById('loop-end-handle') as HTMLDivElement;
	const loopArea = document.querySelector('.loop-area') as HTMLDivElement;

	// Load audio file
	audioFileInput.addEventListener('change', (e) => {
		const file = (e.target as HTMLInputElement).files?.[0];
		if (file) {
			// Validate file type
			const validAudioTypes = ['audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/ogg', 'audio/m4a', 'audio/aac'];
			const fileExtension = file.name.toLowerCase().split('.').pop();
			const validExtensions = ['mp3', 'wav', 'ogg', 'm4a', 'aac'];
			
			if (!validAudioTypes.includes(file.type) && !validExtensions.includes(fileExtension || '')) {
				alert('Invalid audio file. Please select a valid audio file (MP3, WAV, OGG, M4A, AAC).');
				audioFileInput.value = '';
				return;
			}
			
			// Check file size (limit to 100MB)
			const maxSize = 100 * 1024 * 1024; // 100MB in bytes
			if (file.size > maxSize) {
				alert('File is too large. Please select a file smaller than 100MB.');
				audioFileInput.value = '';
				return;
			}
			
			const url = URL.createObjectURL(file);
			if (audio) {
				audio.pause();
				URL.revokeObjectURL(audio.src);
			}
			audio = new Audio(url);
			audio.volume = parseInt(volumeControl.value) / 100;
			
			// Add error handler for corrupted/invalid audio files
			audio.addEventListener('error', () => {
				alert('Unable to load audio file. The file may be corrupted or in an unsupported format.');
				URL.revokeObjectURL(url);
				audioFileInput.value = '';
				audioPlayer.classList.add('hidden');
			});
			
			audio.addEventListener('loadedmetadata', () => {
				// Additional validation - check if duration is valid
				if (!audio!.duration || isNaN(audio!.duration) || audio!.duration === Infinity) {
					alert('Invalid audio file. Unable to read file duration.');
					URL.revokeObjectURL(url);
					audioFileInput.value = '';
					return;
				}
				
				durationDisplay.textContent = formatTime(audio!.duration);
				seekBar.max = audio!.duration.toString();
				audioPlayer.classList.remove('hidden');
				audioLoaded = true;
				checkFilesLoaded();
				// Create markers if lyrics are already loaded
				if (lyrics.length > 0) {
					createLyricMarkers();
					// Jump to first lyric timestamp
					if (lyrics[0].time > 0) {
						audio!.currentTime = lyrics[0].time;
					}
				}
			});

			audio.addEventListener('timeupdate', updateProgress);
			audio.addEventListener('ended', () => {
				playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
			});
		}
	});

	// Load lyrics file (LRC format)
	lyricsFileInput.addEventListener('change', async (e) => {
		const file = (e.target as HTMLInputElement).files?.[0];
		if (file) {
			// Validate file type
			const validLyricTypes = ['text/plain', 'application/octet-stream', ''];
			const fileExtension = file.name.toLowerCase().split('.').pop();
			
			if (fileExtension !== 'lrc' && fileExtension !== 'txt') {
				alert('Invalid lyrics file. Please select an LRC or TXT file.');
				lyricsFileInput.value = '';
				return;
			}
			
			// Check file size (limit to 5MB for text files)
			const maxSize = 5 * 1024 * 1024; // 5MB in bytes
			if (file.size > maxSize) {
				alert('Lyrics file is too large. Please select a file smaller than 5MB.');
				lyricsFileInput.value = '';
				return;
			}
			
			try {
				const text = await file.text();
				
				// Validate that it's actually text content
				if (text.includes('\x00') || text.includes('\uFFFD')) {
					alert('Invalid lyrics file. File appears to be binary or corrupted.');
					lyricsFileInput.value = '';
					return;
				}
				
				lyrics = parseLRC(text);
				
				if (lyrics.length === 0) {
					alert('No valid lyrics found in file. Please check the LRC format:\n[mm:ss.xx]Lyric text');
					lyricsFileInput.value = '';
					return;
				}
				
				lyricsDisplay.classList.remove('hidden');
				displayUpcomingLyrics();
				lyricsLoaded = true;
				checkFilesLoaded();
				// Create markers immediately when lyrics are loaded
				setTimeout(() => {
					if (audio && audio.duration) {
						createLyricMarkers();
						// Jump to first lyric timestamp
						if (lyrics[0].time > 0) {
							audio!.currentTime = lyrics[0].time;
						}
					}
				}, 100);
			} catch (error) {
				alert('Error reading lyrics file. Please ensure it is a valid text file.');
				lyricsFileInput.value = '';
				console.error('Lyrics file error:', error);
			}
		}
	});

	// Check if both files are loaded to hide file inputs
	function checkFilesLoaded() {
		if (audioLoaded && lyricsLoaded) {
			fileInputsSection.classList.add('collapsed');
			countInControl.classList.remove('hidden');
		}
	}

	// Count-in checkbox handler
	countInEnable.addEventListener('change', () => {
		countInBeatsSelect.disabled = !countInEnable.checked;
	});

	// Count-in beats selection
	countInBeatsSelect.addEventListener('change', () => {
		countInBeats = parseInt(countInBeatsSelect.value);
	});

	// Loop checkbox handler
	loopEnable.addEventListener('change', () => {
		loopEnabled = loopEnable.checked;
		if (loopEnabled) {
			loopTrack.classList.remove('hidden');
			if (audio && audio.duration) {
				// Initialize loop points - start at first lyric or beginning, end at last lyric or end
				if (lyrics.length > 0) {
					loopStart = lyrics[0].time;
					loopEnd = lyrics[lyrics.length - 1].time || audio.duration;
				} else {
					loopStart = 0;
					loopEnd = audio.duration;
				}
				updateLoopVisuals();
				// Jump to loop start
				audio.currentTime = loopStart;
			}
		} else {
			loopTrack.classList.add('hidden');
		}
	});

	// Loop handle dragging - prevent default drag behavior
	loopStartHandle.addEventListener('dragstart', (e) => e.preventDefault());
	loopEndHandle.addEventListener('dragstart', (e) => e.preventDefault());

	loopStartHandle.addEventListener('mousedown', (e) => {
		console.log('Start handle mousedown');
		isDraggingLoop = true;
		currentDragHandle = 'start';
		// Pause audio while dragging
		if (audio && !audio.paused) {
			audio.pause();
			// Remember to resume after drag
			(loopStartHandle as any).wasPlaying = true;
		}
		e.preventDefault();
		e.stopPropagation();
	});

	loopEndHandle.addEventListener('mousedown', (e) => {
		console.log('End handle mousedown');
		isDraggingLoop = true;
		currentDragHandle = 'end';
		e.preventDefault();
		e.stopPropagation();
	});

	// Touch support for mobile
	loopStartHandle.addEventListener('touchstart', (e) => {
		isDraggingLoop = true;
		currentDragHandle = 'start';
		e.preventDefault();
	});

	loopEndHandle.addEventListener('touchstart', (e) => {
		isDraggingLoop = true;
		currentDragHandle = 'end';
		e.preventDefault();
	});

	document.addEventListener('mousemove', (e) => {
		if (!isDraggingLoop || !audio || !currentDragHandle) return;

		const trackRect = loopTrack.getBoundingClientRect();
		const percent = ((e.clientX - trackRect.left) / trackRect.width) * 100;
		const clampedPercent = Math.max(0, Math.min(100, percent));

		if (currentDragHandle === 'start') {
			const endPercent = parseFloat(loopEndHandle.style.left || '90');
			const maxPercent = endPercent - 5;
			const finalPercent = Math.min(clampedPercent, maxPercent);
			loopStartHandle.style.left = `${finalPercent}%`;
			loopStart = (finalPercent / 100) * audio.duration;
			// Move playhead along with start marker
			audio.currentTime = loopStart;
		} else if (currentDragHandle === 'end') {
			const startPercent = parseFloat(loopStartHandle.style.left || '10');
			const minPercent = startPercent + 5;
			const finalPercent = Math.max(clampedPercent, minPercent);
			loopEndHandle.style.left = `${finalPercent}%`;
			loopEnd = (finalPercent / 100) * audio.duration;
		}

		updateLoopArea();
	});

	document.addEventListener('touchmove', (e) => {
		if (!isDraggingLoop || !audio || !currentDragHandle) return;
		
		const touch = e.touches[0];
		const trackRect = loopTrack.getBoundingClientRect();
		const percent = ((touch.clientX - trackRect.left) / trackRect.width) * 100;
		const clampedPercent = Math.max(0, Math.min(100, percent));

		if (currentDragHandle === 'start') {
			const endPercent = parseFloat(loopEndHandle.style.left || '90');
			const maxPercent = endPercent - 5;
			const finalPercent = Math.min(clampedPercent, maxPercent);
			loopStartHandle.style.left = `${finalPercent}%`;
			loopStart = (finalPercent / 100) * audio.duration;
			// Move playhead along with start marker
			audio.currentTime = loopStart;
		} else if (currentDragHandle === 'end') {
			const startPercent = parseFloat(loopStartHandle.style.left || '10');
			const minPercent = startPercent + 5;
			const finalPercent = Math.max(clampedPercent, minPercent);
			loopEndHandle.style.left = `${finalPercent}%`;
			loopEnd = (finalPercent / 100) * audio.duration;
		}

		updateLoopArea();
		e.preventDefault();
	});

	document.addEventListener('mouseup', () => {
		if (isDraggingLoop) {
			console.log('Drag ended. Loop:', loopStart, 'to', loopEnd);
			
			// Resume playback if it was playing before drag
			if ((loopStartHandle as any).wasPlaying && audio) {
				audio.play();
				(loopStartHandle as any).wasPlaying = false;
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			}
		}
		isDraggingLoop = false;
		currentDragHandle = null;
	});

	document.addEventListener('touchend', () => {
		isDraggingLoop = false;
		currentDragHandle = null;
	});

	function updateLoopVisuals() {
		if (!audio) return;
		const startPercent = (loopStart / audio.duration) * 100;
		const endPercent = (loopEnd / audio.duration) * 100;
		loopStartHandle.style.left = `${startPercent}%`;
		loopEndHandle.style.left = `${endPercent}%`;
		updateLoopArea();
	}

	function updateLoopArea() {
		const startPercent = parseFloat(loopStartHandle.style.left || '10');
		const endPercent = parseFloat(loopEndHandle.style.left || '90');
		loopArea.style.left = `${startPercent}%`;
		loopArea.style.width = `${endPercent - startPercent}%`;
	}

	// Parse LRC format: [mm:ss.xx]Lyric text
	function parseLRC(lrcText: string): Array<{ time: number; text: string }> {
		const lines = lrcText.split('\n');
		const parsed: Array<{ time: number; text: string }> = [];
		
		const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;
		
		for (const line of lines) {
			const matches = [...line.matchAll(timeRegex)];
			if (matches.length > 0) {
				const text = line.replace(timeRegex, '').trim();
				if (text) {
					for (const match of matches) {
						const minutes = parseInt(match[1]);
						const seconds = parseInt(match[2]);
						const centiseconds = parseInt(match[3].padEnd(2, '0').slice(0, 2));
						const time = minutes * 60 + seconds + centiseconds / 100;
						parsed.push({ time, text });
					}
				}
			}
		}
		
		return parsed.sort((a, b) => a.time - b.time);
	}

	// Create click sound for count-in
	function createClickSound() {
		const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
		const oscillator = audioContext.createOscillator();
		const gainNode = audioContext.createGain();
		
		oscillator.connect(gainNode);
		gainNode.connect(audioContext.destination);
		
		oscillator.frequency.value = 1000;
		oscillator.type = 'sine';
		
		gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
		gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
		
		oscillator.start(audioContext.currentTime);
		oscillator.stop(audioContext.currentTime + 0.1);
	}

	// Play/Pause control
	playPauseBtn.addEventListener('click', async () => {
		if (!audio) return;
		
		if (audio.paused) {
			// Check if count-in is enabled and we're at/before the first lyric
			const isAtStart = lyrics.length > 0 ? audio.currentTime <= lyrics[0].time : audio.currentTime === 0;
			
			if (countInEnable.checked && isAtStart && lyrics.length > 0) {
				const beatsCount = parseInt(countInBeatsSelect.value);
				
				// Jump to first lyric position if not already there
				if (lyrics[0].time > 0) {
					audio.currentTime = lyrics[0].time;
				}
				
				// Display count-in beats with click sound
				for (let i = 1; i <= beatsCount; i++) {
					createClickSound();
					currentLyricDisplay.textContent = `${i}`;
					currentLyricDisplay.style.fontSize = 'clamp(3rem, 10vw, 5rem)';
					currentLyricDisplay.style.color = 'var(--accent-regular)';
					
					// Wait 1 second before next beat
					await new Promise(resolve => setTimeout(resolve, 1000));
				}
				
				// Reset font size and start playback
				currentLyricDisplay.style.fontSize = '';
				currentLyricDisplay.style.color = '';
				currentLyricDisplay.textContent = '';
				
				audio.play();
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			} else {
				audio.play();
				playPauseBtn.querySelector('.play-icon')?.classList.add('hidden');
				playPauseBtn.querySelector('.pause-icon')?.classList.remove('hidden');
			}
		} else {
			audio.pause();
			playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
			playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
		}
	});

	// Stop control
	stopBtn.addEventListener('click', () => {
		if (!audio) return;
		audio.pause();
		audio.currentTime = 0;
		
		playPauseBtn.querySelector('.play-icon')?.classList.remove('hidden');
		playPauseBtn.querySelector('.pause-icon')?.classList.add('hidden');
		currentLyricIndex = -1;
		displayUpcomingLyrics();
	});

	// Seek control
	seekBar.addEventListener('input', () => {
		if (!audio) return;
		audio.currentTime = parseFloat(seekBar.value);
	});

	// Volume control
	volumeControl.addEventListener('input', () => {
		if (!audio) return;
		audio.volume = parseInt(volumeControl.value) / 100;
	});

	// Update progress and lyrics
	function updateProgress() {
		if (!audio) return;
		
		const currentTime = audio.currentTime;
		currentTimeDisplay.textContent = formatTime(currentTime);
		seekBar.value = currentTime.toString();
		const progress = (currentTime / audio.duration) * 100;
		progressFill.style.width = `${progress}%`;

		// Update playhead indicator position
		const playheadIndicator = document.querySelector('.playhead-indicator') as HTMLElement;
		if (playheadIndicator) {
			playheadIndicator.style.left = `calc(${progress}% - 8px)`;
		}

		// Handle loop
		if (loopEnabled && currentTime >= loopEnd) {
			audio.currentTime = loopStart;
		}

		// Update lyrics
		updateLyrics(currentTime);
		updateMarkers(currentTime);
	}

	function updateLyrics(currentTime: number) {
		if (lyrics.length === 0) return;

		// Find current lyric
		let newIndex = -1;
		for (let i = 0; i < lyrics.length; i++) {
			if (lyrics[i].time <= currentTime) {
				newIndex = i;
			} else {
				break;
			}
		}

		if (newIndex !== currentLyricIndex) {
			currentLyricIndex = newIndex;
			
			if (currentLyricIndex >= 0) {
				currentLyricDisplay.textContent = lyrics[currentLyricIndex].text;
			} else {
				currentLyricDisplay.textContent = '';
			}
			
			displayUpcomingLyrics();
		}
	}

	function displayUpcomingLyrics() {
		const startIndex = Math.max(0, currentLyricIndex + 1);
		const endIndex = Math.min(lyrics.length, startIndex + 3);
		const upcoming = lyrics.slice(startIndex, endIndex);
		
		upcomingLyricsDisplay.innerHTML = upcoming
			.map(lyric => `<span class="lyric-line">${lyric.text}</span>`)
			.join('');
	}

	// Create visual markers for lyric timestamps
	function createLyricMarkers() {
		if (!audio || lyrics.length === 0) {
			console.log('Cannot create markers:', { audio: !!audio, lyricsCount: lyrics.length });
			return;
		}
		
		const markersContainer = document.getElementById('lyric-markers');
		if (!markersContainer) {
			console.log('Markers container not found');
			return;
		}
		
		markersContainer.innerHTML = '';
		const duration = audio.duration;
		
		console.log('Creating markers for', lyrics.length, 'lyrics, duration:', duration);
		
		lyrics.forEach((lyric, index) => {
			const marker = document.createElement('div');
			marker.className = 'lyric-marker';
			marker.dataset.index = index.toString();
			const position = (lyric.time / duration) * 100;
			marker.style.left = `${position}%`;
			marker.style.transform = 'translateX(-50%)';
			marker.style.backgroundColor = '#888'; // Force background color
			marker.style.width = '3px'; // Force width
			marker.style.height = '100%'; // Force height
			marker.style.position = 'absolute'; // Force position
			marker.style.top = '0'; // Force top
			markersContainer.appendChild(marker);
			console.log(`Marker ${index}: ${lyric.time}s at ${position}%`, marker);
		});
		
		console.log('Markers created:', markersContainer.children.length);
		console.log('Markers container:', markersContainer, 'Computed style:', window.getComputedStyle(markersContainer));
	}

	// Update active marker
	function updateMarkers(currentTime: number) {
		const markers = document.querySelectorAll('.lyric-marker');
		markers.forEach((marker) => {
			const index = parseInt((marker as HTMLElement).dataset.index || '-1');
			if (index === currentLyricIndex) {
				marker.classList.add('active');
			} else {
				marker.classList.remove('active');
			}
		});
	}

	function formatTime(seconds: number): string {
		const mins = Math.floor(seconds / 60);
		const secs = Math.floor(seconds % 60);
		return `${mins}:${secs.toString().padStart(2, '0')}`;
	}
</script>
